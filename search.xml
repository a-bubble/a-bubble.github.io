<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql基础知识</title>
      <link href="/2019/06/03/mySql/"/>
      <url>/2019/06/03/mySql/</url>
      
        <content type="html"><![CDATA[<p>01.Mysql基础架构：<br><img src="/2019/06/03/mySql/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="enter description here"><br>Server层：涵盖MySql大多数核心服务功能。内置函数、跨搜索引擎的功能也在这里实现，如存储过程、触发器、试图。<br>存储引擎层：负责数据的存储和提取。架构模式：插件式 MySql5.5.5之后InnoDB是默认存储引擎<br><a id="more"></a><br>连接器：负责客户端与服务器建立连接、获取权限、维持和管理链接<br>MySql占用内存问题：mysql执行过程中使用的内存是管理在连接对象里。这些资源要在连接断开时候释放。长时间积累导致内存占用太大，被系统杀掉导致mysql异常重启。<br> 解决办法：<br> 1.定期断开长连接，之后要查询重连<br> 2.mysql5.7+每次执行一个较大操作后，通过执行mysql_reset_connection重新初始化资源。过程中不需要重连或者重新验证权限。</p><p> 查询缓存<br> mysql拿到一个查询请求之后，会先到查询缓存看看，是否执行过这条语句。执行过的K-V存储。k-执行语句 v-结果<br> if找到key return value给客户端<br> 查询缓存不建议：why?<br> 查询缓存失效频繁，只要对一个表更新，这个表的所有缓存都会被清空。更新压力大的数据库，缓存命中率很低。静态表，很久更新一次适合缓存，比如配置表。<br> Mysql8无查询缓存模块</p><p> 分析器：<br> 做词法分析 然后语法分析判断是否符合语法规则</p><p> 优化器：<br> 开始执行语句之前，需要进行优化器优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * <span class="keyword">from</span> t1 join t2 using(ID)  where t1.c=<span class="number">10</span> and t2.d=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>1.先从表t1取出c=10的记录值，再根据id关联到表2，判断是否等于20<br>2..先表2再表1</p><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而…<br>优化器阶段完成之后，就进入执行阶段。</p><p>执行器：<br>开始执行，先判断要执行的表有没有查询权限。权限验证成功就开始打开表执行。执行器会根据表的引擎定义使用这个引擎提供的接口<br>查询语句执行过程解析：<br>1.调用引擎接口第一行，判断，如果满足条件将这行存在结果集。不是跳过<br>2.调用引擎接口取下一行，重复1的逻辑，直到取到表的最后一行<br>3.执行器将上述满足条件的结果集返回给客户端</p><p>02日志系统<br>Mysql更新语句<br>update T set c=c+1 where ID=2;<br>与查询语句不一样，更新语句还涉及到两个重要的日志模块：<br>redo log重做日志<br>bin log 归档日志<br>重做日志：<br>mysql中，如果每一次更新操作都写入磁盘的话，IO，查找成本都很高。MYsql解决这个问题使用：WAL技术。write-ahead-logging<br>就是先写日志，再写磁盘。<br>具体分析：当有一条记录需要更新额话，引擎先把记录写入redo log，更新内存，这时候更新就算完成了。引擎会在适当的时候将这个更操作记录更新到磁盘里。往往是系统比较闲的时候做。<br>InnoDB 的 redo log 是固定大小的，比如可以一组配置4个文件，每个文件大小1G 一共就是4G.从头开始，写到末尾再开始从头循环。<br><img src="/2019/06/03/mySql/16a7950217b3f0f4ed02db5db59562a7.png" alt="enter description here"></p><p>write pos 是当前记录的位置，一边写一遍后移，写到3号文件末尾回到0号文件开头。checkpoint是当前要擦除的位置。一边写一边右移。当write point追上checkpoint，表示已经满了。要擦除一些记录，把checkpoint推进一下。<br>redo log可以保证即使数据库发生异常重启，之前 提交的记录也不会丢失。就是crash-safe。</p><p>bin log:归档日志<br>redo log是InnoDB引擎特有的，binlog是Mysql server层实现的，所有引擎都可以使用。<br>redo log是物理日志，记录的是在某个数据页上做了什么修改，binlog是逻辑日志，记录的是语句的原始逻辑。<br>redo log是循环写的。空间固定会用完。binlog是追加写，文件写到一定大小会切换到下一个不会覆盖以前的日志。</p><p>执行update语句的内部流程。<br>1.执行器先找引擎取id=2这一行。id是主键，引擎直接用树搜索找到这一行。如果id=2这一行就在内存中直接返回结果给执行器。否则先从磁盘读入内存，然后返回。<br>2.执行器拿到引擎给的行数据，把这个值加上1，原来是N,现在就是N+1,得到新的数据行，调用 引擎接口写入这行新数据<br>3.引擎将这行数据更新到内存中，将更新记录记录到redo log，此时redo log处于prepare 状态，告知执行器完成了，随时可以提交事务<br>4.执行器生成这个操作的binlog，并把binlog写入磁盘。<br>5.执行器调用引擎提交事务接口，引擎把刚刚写入redo log改成commit状态。更新完成<br><img src="/2019/06/03/mySql/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="enter description here"></p><p>上述过程中两阶段提交的作用：<br>为了让两个日志之间逻辑一致<br>假设：<br>1.先写redo log后写binlog，假设redo log写完了，binlog还未写完，mysql进程重启。这时候 binlog还没写完，这样的话 用binlog恢复的数据库与之前是不一致的。<br>2.先写binlog后写redo log的话，在binlog写完之后crash，redo log还没有写，崩溃后事务无效，但是binlog已经记录了这一条，用binlog恢复与原数据库不一致。<br>由此可见，不使用两阶段的话，数据库状态可能与恢复的数据库状态不一致。<br>误操作 扩容 备份库 都是用全量备份加上应用binlog来实现。 不一致就会导致线上出现主从库不一致。<br>binlog与redo log都可以表示事务的提交状态，两阶段提交就是让这两个状态逻辑上保持一致。<br>总结：<br>两阶段提交是跨系统维持数据逻辑一致性的常用方案。</p><p>03 事务隔离<br>事务：原子性，一致性，隔离性，持久性<br>事务并发产生的问题：<br>1.脏读：当一个事务正在访问数据库并对数据进行了修改，但是这个修改还未提交到数据库中，这时，另外一个事务也访问了这个数据，然后使用了这个数据。<br>2.不可重复读：在一个事务中，多次读同一个数据，这个事务还未结束，另一个事务也访问该同一数据。那么在一个事务的两次读之间，由于事务的修改，那么第一次事务读到的数据可能是不一样的。这样放生在一个事务内两次数据读到的不一致，就是不可重复读。<br>3.幻读：两次 执行结果集不一致<br>解决以上问题：隔离级别问题<br>隔离的越是严实效率就会越低<br>读未提交：一个事务还没提交，变更就可以被其他事务看见<br>读提交：一个事务提交之后变更才可以被其他事务看见<br>可重复读：一个事务执行中看到的数据总是和事务启动时看到的数据是一致的，即未提交的变更对其他事务不可见。<br>串行化：对同一行数据，写会加写锁，读会加读锁。读写冲突时，后访问的事务等前一个事务执行完成。<br><img src="/2019/06/03/mySql/7dea45932a6b722eb069d2264d0066f8.png" alt="enter description here"><br>读未提交：v1,v2,v3都是2 因为事务B的修改即使未提交对事务A也是可见的<br>读提交：v1=1,v2,v3=2<br>可重复读：事务A未提交过程中事务看到的数据都是一致的，V1 V2都是1 V3=2<br>串行化：事务B的改值会被锁住直到事务A提交。所以A提交之前v1 v2=1  A提交之后，B执行加1，V3=2</p><p>在实现上：<br>数据库会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读隔离级别下，这个视图是事务启动时创建的，整个事务存在期间都用这个视图。在读未提交隔离级别下，这个视图是每个sql语句开始执行时创建的。<br>读未提交直接返回记录上最新值，没有视图概念。串行化直接加锁。<br>Oracle默认隔离级别是读提交 MySql是可重复读<br>可重复读使用场景：对账单，一张表是月底余额，一张是交易明细。对账过程中如果发生交易改变余额会影响对账。所以可重复读比较有用。<br>所谓事务：是一个完整的不可分割的数据处理单元。该单元中所有数据处理要么全部成功，要么因为其中任意一个操作的失败而完成完全回滚至事务处理前的状态。<br>尽量不使用长事务：长事务意味里边会存在很老的事务视图。回滚记录也需要保留，导致要占用大量的内存空间。长事务还会用到锁，也可能会拖垮数据库。</p><p>04 索引<br>索引作用：提高查询效率<br>①基于哈希表的 哈希表结构适用于等值查询的场景  新增速度很快 但是因为索引不是递增的 所以哈希索引做区间查询的速度会很慢<br>②基于有序数组的 范围查询效率很高 但是新增的时候很麻烦 往中间插入一个 就必须移动后边所有的记录 成本太高 有序数组索引只适用于静态存储引擎<br>③二叉索引树 搜索效率高 数据存储在磁盘 寻址过慢 尽量少读磁盘 查询过程中访问尽量少的数据块</p><p>在Mysql中 索引是在存储引擎层实现 不同存储引擎索引的工作方式也不一样</p><p>INnoDB的索引模型：<br>根据叶子节点的内容，索引可以分为：主键索引与非主键索引<br>主键索引，叶子节点存储的是整行数据，也叫聚簇索引<br>非主键索引：叶子节点存储的是主键的值。也叫二级索引<br><img src="/2019/06/03/mySql/dcda101051f28502bd5c4402b292e38d.png" alt="enter description here"></p><p>使用二级索引的话，需要多扫描一遍，索引尽量应该使用主键索引<br>非主键索引，有一个回表的过程 回表：回到主键索引树的过程</p><p>索引的维护：<br>B+树索引 为了维护索引有序性 在插入新值 的时候需要做必要的维护<br>哪些场景要使用自增主键，哪些场景不需要使用？<br>自增主键保证插入的时候不需要触发叶子节点的分裂。而有业务逻辑的 字段做主键，往往不能保证有序插入。写数据的成本相对较高。<br>对于普通索引，自增主键长度较小，占用空间较少从性能和空间占用上分析，自增主键更合理。<br>数据库主键到底是用自增长（INT）好还是UUID好？<br><a href="https://blog.csdn.net/caodongfang126/article/details/76977942" target="_blank" rel="noopener">https://blog.csdn.net/caodongfang126/article/details/76977942</a><br>一张表其实是几个B+树 树节点的key就是某一行的主键 新建索引 就是新增一个B+树 查询不走索引就是遍历主B+树<br>执行 select * from T where k between 3 and 5 需要执行几次树的搜索操作？<br>根据上图的索引结构，在k索引树上找到K=3的记录，取得ID=300<br>再到ID 索引树查找ID=300对应的行 （回表）<br>在K索引树取下一个K=5，取得ID=500<br>再回到ID索引树查到ID=500对应的行（回表）<br>再到K索引树取下一个值K=6 不满足条件 循环结束</p><p>上述过程查询结果只在主键索引上，所以不得不回表。如何优化？避免回表？<br>索引覆盖：select  id  from T where k between 3 and 5 只需要查询ID的值，ID的值，而ID的值已经在K索引树上，可直接提供查询结果无需回表过程<br>覆盖索引可以减少树的搜素次数 提升查询性能 是一种常用的优化手段</p><p>联合索引：<br>例子：    在一个市民信息表上，如果频繁通过身份证号查询名字，可以建一个身份证号-姓名联合索引，可以在这个高频请求上用到覆盖索引，不需要回表，减少语句执行时间。<br>当然，索引的维护需要代价。因此建立冗余索引来支持覆盖索引需要权衡考虑</p><p>建立联合索引，安排索引内字段顺序：<br>1.通过调整顺序可以少维护一个索引 2空间</p><p>索引下推：对索引中包含的字段进行判断，过滤掉不满足条件的记录，减少回表次数<br>删除表的部分记录，但是索引还在，还会占用空间，重建表才会重建索引。<br>数据量大的时候，二级索引的覆盖索引更快</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/05/30/linkedList/"/>
      <url>/2019/05/30/linkedList/</url>
      
        <content type="html"><![CDATA[<p>1.链表反转：从m-n反转<br>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;</span><br><span class="line">    LinkedList next;</span><br><span class="line">    int val;</span><br><span class="line">public LinkedList(int val)&#123;</span><br><span class="line">    <span class="keyword">this</span>.val=val;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">    LinkedList node1=<span class="keyword">new</span> LinkedList(<span class="number">1</span>);</span><br><span class="line">    LinkedList node2=<span class="keyword">new</span> LinkedList(<span class="number">2</span>);</span><br><span class="line">    LinkedList node3=<span class="keyword">new</span> LinkedList(<span class="number">3</span>);</span><br><span class="line">    LinkedList node4=<span class="keyword">new</span> LinkedList(<span class="number">4</span>);</span><br><span class="line">    LinkedList node5=<span class="keyword">new</span> LinkedList(<span class="number">5</span>);</span><br><span class="line">    node1.next=node2;</span><br><span class="line">    node2.next=node3;</span><br><span class="line">    node3.next=node4;</span><br><span class="line">    node4.next=node5;</span><br><span class="line">    print(node1);</span><br><span class="line">    LinkedList new_node=reverse(node1,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">    print(new_node);</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> print(LinkedList node)&#123;</span><br><span class="line">    <span class="keyword">while</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(node.val);</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">static</span> LinkedList reverse(LinkedList head,int m,int n)&#123;</span><br><span class="line">    int change_count=n-m+<span class="number">1</span>;<span class="comment">//计算翻转长度</span></span><br><span class="line">    LinkedList pre_head=<span class="literal">null</span>;<span class="comment">//m的前驱节点</span></span><br><span class="line">    LinkedList result=head;<span class="comment">//翻转后整个链表的头结点 作为返回值</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span> &amp;&amp; --m&gt;<span class="number">0</span>)&#123;<span class="comment">//找到前驱节点与翻转开始节点</span></span><br><span class="line">        pre_head=head;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList modify_last_tail=head;<span class="comment">//翻转后的尾节点</span></span><br><span class="line">    LinkedList new_head=<span class="literal">null</span>;<span class="comment">//辅助翻转</span></span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>&amp;&amp;change_count&gt;<span class="number">0</span>)&#123;<span class="comment">//和普通翻转一样</span></span><br><span class="line">        LinkedList next=head.next;</span><br><span class="line">        head.next=new_head;</span><br><span class="line">        new_head=head;</span><br><span class="line">        head=next;</span><br><span class="line">        change_count--;</span><br><span class="line">    &#125;</span><br><span class="line">    modify_last_tail.next=head;<span class="comment">//尾节点指向n的下一节点</span></span><br><span class="line">    <span class="keyword">if</span>(pre_head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        pre_head.next=new_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        result=new_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.判断两个链表的交点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> LinkedList getSameNode(LinkedList node1,LinkedList node2)&#123;</span><br><span class="line">    <span class="built_in">Set</span>&lt;LinkedList&gt; <span class="keyword">set</span>=new HashSet&lt;&gt;();</span><br><span class="line">    while(node1!=null)&#123;</span><br><span class="line">        <span class="keyword">set</span>.add(node1);</span><br><span class="line">        node1=node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(node2!=null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">set</span>.contains(node2))&#123;</span><br><span class="line">            <span class="keyword">return</span> node2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            node2=node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.判断回环链表是否有环，返回环的起始节点<br> ①利用set的性质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public <span class="keyword">static</span> LinkedList getCircle(LinkedList node)&#123;</span><br><span class="line">    <span class="built_in">Set</span>&lt;LinkedList&gt; <span class="keyword">set</span>=new HashSet&lt;&gt;();</span><br><span class="line">    while(node!=null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">set</span>.contains(node))&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>.add(node);</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②使用快慢指针<br>快指针每次两步 慢指针每次一步 有环的话肯定能相遇 但是相遇的地点不是起始位置 指针头到交点距离==相遇点到交点距离<br>所以：判断有环 然后判断交点<br>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> LinkedList getCircle2(LinkedList node)&#123;</span><br><span class="line">    LinkedList fast=node;</span><br><span class="line">    LinkedList slow=node;</span><br><span class="line">    LinkedList meet=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">            meet=fast;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(meet==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(meet!=<span class="literal">null</span>&amp;&amp;node!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(meet==node)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        meet=meet.next;</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.leetcode 86 链表重排 不改变相对前后位置<br>利用dummy node思想 小于X的放在一个链表 大于X的放在一个链表 最后连接两个链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> LinkedList resort(LinkedList head,int x)&#123;</span><br><span class="line">    LinkedList bigerDummy=<span class="keyword">new</span> LinkedList(<span class="number">-1</span>);</span><br><span class="line">    LinkedList lowerDummy=<span class="keyword">new</span> LinkedList(<span class="number">-1</span>);</span><br><span class="line">    LinkedList ptr_b=bigerDummy;</span><br><span class="line">    LinkedList ptr_s=lowerDummy;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val&lt;x)&#123;</span><br><span class="line">            ptr_s.next=head;</span><br><span class="line">            ptr_s=head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ptr_b.next=head;</span><br><span class="line">            ptr_b=head;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr_s.next=bigerDummy.next;</span><br><span class="line">    ptr_b.next=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> lowerDummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5 求链表的深度拷贝<br>待续</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2019/05/29/java1/"/>
      <url>/2019/05/29/java1/</url>
      
        <content type="html"><![CDATA[<p>管道：就是连通两个线程通信的缓冲区<br>1.基于输入输出流<br>&ensp;这种情况就是阻塞的，单向的。<br>写进程通过管道输出流把数据写入管道，读进程通过管道输入流从管道拿数据<br>所谓阻塞：当管道输出流write()导致管道缓冲区变满时，管道的write()调用将默认的被阻塞，等待缓冲区的数据被读取。同样的读进程也可能工作得比写进程块。当所有当前进程数据被读取时，管道变空。当这种情况发生时，一个随后的read()调用将默认被阻塞，等待缓冲区数据，这解决了read()调用返回文件结束的问题<br>管道数据流是单向的，数据只能从进程（线程）的一端流向另一个进程（线程）的另一端。如果要进行双向通信 就要建立两个管道。<br>管道读数据是一次性操作，数据一旦被读，就会被从管道中抛弃，释放更多空间以便写入。<br>管道输出流或者管道输入流的提前关闭，不会影响到对端流。比如输出流提前结束，输入流不会产生异常；输入流的提前结束也不会影响到输出流。管道通信结束后一定要关闭输出流。输入流通过read（是否返回null来判断管道通信是否结束）</p><p>实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">private PipedOutputStream  pos;</span><br><span class="line">public Writer(PipedOutputStream pos)&#123;</span><br><span class="line"><span class="keyword">this</span>.pos=pos;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">PrintStream p=<span class="keyword">new</span> PrintStream(pos);</span><br><span class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.currentThread().sleep(<span class="number">250</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">p.println(i);</span><br><span class="line">System.out.println(<span class="string">"write +"</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">p.flush();</span><br><span class="line">p.close();</span><br><span class="line">System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">private PipedInputStream pis;</span><br><span class="line">private <span class="built_in">String</span> line;</span><br><span class="line">public Reader(PipedInputStream pis)&#123;</span><br><span class="line"><span class="keyword">this</span>.pis=pis;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="keyword">void</span> run()&#123;</span><br><span class="line">BufferedReader b=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(pis));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">line=b.readLine();</span><br><span class="line"><span class="keyword">if</span>(line!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (line != <span class="literal">null</span>)</span><br><span class="line">System.out.println(<span class="string">"Read:"</span> + line);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">"done"</span>);</span><br><span class="line">Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(b!=<span class="literal">null</span>&amp;&amp;line!=<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ThreadPipe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="built_in">String</span>[] args) throws IOException&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">PipedOutputStream  pos=<span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">PipedInputStream pis=<span class="keyword">new</span> PipedInputStream(pos);</span><br><span class="line"><span class="keyword">new</span> Writer(pos).start();</span><br><span class="line"><span class="keyword">new</span> Reader(pis).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2019/05/29/java1/微信图片_20190529110201.png" alt="enter description here"></p><h6 id="Join-方法："><a href="#Join-方法：" class="headerlink" title="Join()方法："></a>Join()方法：</h6><p>join()通常在主线程里调用。有时候主线程要比子线程提前结。当主线程main()想等子线程t结束之后再结束，就要使用t.jion().所以，join的作用：阻塞调用该方法的线程（main)，直至t完成，此进程再继续执行。join（）相当于将线程加入等待队列。<br>join()方法实现是通过wait()（小提示：Object 提供的方法）。 当main线程调用threadA.join时候，main线程会获得线程对象threadA的锁（wait 意味着拿到该对象的锁),调用该对象的wait(等待时间)，直到该对象唤醒main线程 （也就是子线程threadA执行完毕退出的时候）<br>总结</p><p>首先join() 是一个synchronized方法， 里面调用了wait()，这个过程的目的是让持有这个同步锁的线程进入等待，那么谁持有了这个同步锁呢？答案是主线程，因为主线程调用了threadA.join()方法，相当于在threadA.join()代码这块写了一个同步代码块，谁去执行了这段代码呢，是主线程，所以主线程被wait()了。然后在子线程threadA执行完毕之后，JVM会调用lock.notify_all(thread);唤醒持有threadA这个对象锁的线程，也就是主线程，会继续执行。<br>参考：非常清晰！<a href="https://blog.csdn.net/u010983881/article/details/80257703" target="_blank" rel="noopener">https://blog.csdn.net/u010983881/article/details/80257703</a></p><p>join()与sleep()比较：<br>实质上就是wait()与sleep()比较：<br> （1）属于不同的两个类，sleep()方法是线程类（Thread）的静态方法，wait()方法是Object类里的方法。</p><p>  （2）sleep()方法不会释放锁，wait()方法释放对象锁。</p><p>   （3）sleep()方法可以在任何地方使用，wait()方法则只能在同步方法或同步块中使用。</p><p>  （4）sleep()必须捕获异常，wait()方法、notify()方法和notiftAll()方法不需要捕获异常。</p><p>   （5）sleep()使线程进入阻塞状态（线程睡眠），wait()方法使线程进入等待队列（线程挂起），也就是阻塞类别不同。</p><h5 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h5><p>   用于存储每个线程自己的私有数据<br>   get()方法获取值，set方法设置值<br>   当LocalThread未设置初始值的时候调用get返回null，覆盖initivalValue()方法使得其具有初始值。<br>ThreadLocal原理:<br>该ThreadLocalMap由ThreadLocal持有会导致线程间争抢资源的问题，但让每个Thread维护该map，每个 Thread 只访问自己的 Map，将不会导致多线程写冲突。也就不需要锁。该方案如下图所示。<br><img src="/2019/05/29/java1/20180502092958420.png" alt="20180502092958420"></p><p>ThreadLocal源码实现</p><p>（1）ThreadLocal<string> local=new ThreadLocal<string>()，t.set(“herock”),为啥直接设置value就知道该value属于哪个线程？</string></string></p><p>1)首先获取到当前线程，通过getMap(t)传入线程获得该线程持有的实例变量ThreadLocalMap。<br><img src="/2019/05/29/java1/20180502093837485.png" alt="20180502093837485"><br>2）getMap(t)返回线程t的实例变量threadLocals<br><img src="/2019/05/29/java1/20180502094127839.png" alt="20180502094127839"></p><p><img src="/2019/05/29/java1/20180502094310309.png" alt="20180502094310309"><br>3）如果threadLocals为null就创建map，如果不为null以ThreadLocal实例为key，以所存值为value存入map.<br>  <img src="/2019/05/29/java1/20180502094632478.png" alt="20180502094632478"></p><p><img src="/2019/05/29/java1/20180502094759872.png" alt="20180502094759872"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer8-9</title>
      <link href="/2019/05/27/offer8/"/>
      <url>/2019/05/27/offer8/</url>
      
        <content type="html"><![CDATA[<h6 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h6><p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a><br>分析：<br>1.如果只有1级台阶，那显然只有一种跳法<br>2.如果有2级台阶，那么就有2种跳法，一种是分2次跳。每次跳1级，另一种就是一次跳2级<br>3.如果台阶级数大于2，设为n的话，这时我们把n级台阶时的跳法看成n的函数，记为,第一次跳的时候有2种不同的选择：一是第一次跳一级，此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)二是第一次跳二级，此时跳法的数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2),因此n级台阶的不同跳法的总数为f(n)=f(n-1)+f(n-2) 是斐波那契数列。<br>如果使用递归的方式的话吗，如果要求f(9)要求f(8)+f(7)求f(8)又要求f(7)+f(6)所以，存在重复计算<br>使用循环的方式，就是从下往上计算，时间复杂度O(n)<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if(target==2)</span><br><span class="line">            return 2;</span><br><span class="line">        if(target==1)</span><br><span class="line">            return 1;</span><br><span class="line">        int count=0;int n1=1; int n2=2;</span><br><span class="line">        for(int i=3;i&lt;=target;i++)&#123;</span><br><span class="line">            count=n1+n2;</span><br><span class="line">            n1=n2;</span><br><span class="line">            n2=count;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h6><p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>解析：<br>f(0) = 1<br>f(1) = 1<br>f(2) = f(2-1)+f(2-1) #跳一步回到f(1)问题，跳两步回到f(0)问题<br>f(3) = f(3-1)+f(3-2)+f(3-3)<br>…<br>f(n-1) = f((n-1)-1)+f((n-1)-2)+…+f((n-1)-(n-1)) = f(n-2)+f(n-3)+…+f(0)<br>f(n) = f(n-1)+f(n-2)+f(n-3)…+f(0) = f(n-1)+f(n-1) = 2*f(n-1) </p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2019/05/21/Java/"/>
      <url>/2019/05/21/Java/</url>
      
        <content type="html"><![CDATA[<h6 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h6><ol><li>数值类型之间转换<br><img src="/2019/05/21/Java/1.png" alt="enter description here"><a id="more"></a>2.字符串判断</li></ol><p><img src="/2019/05/21/Java/2.png" alt="enter description here"></p><p>3.数组拷贝<br><img src="/2019/05/21/Java/3.png" alt="enter description here"></p><p>4.构造器<br><img src="/2019/05/21/Java/4.png" alt="enter description here"></p><p>5.静态方法<br><img src="/2019/05/21/Java/5.png" alt="enter description here"></p><p>6.参数值<br><img src="/2019/05/21/Java/6.png" alt="enter description here"></p><p>7<img src="/2019/05/21/Java/7.png" alt="enter description here"></p><p>8.重载与重写：<br>重写也叫 覆盖 ：子类对父类方法的修改。<br>参数列表与被重写参数列表完全一致。<br>返回类型可以与父类不一样 但是必须属于其派生类型<br>访问权限不能比父类的低<br>声明为final的方法不能重写<br>声明为static 的方法不能被重写 但是可以被声明<br>子类与父类在同一个包里 子类可以重写除了final static外所有方法<br>不在一个包里 只能重写public protected<br>构造方法不能被重写<br>子类中调用父类的被重写方法时，要使用super关键字。 </p><p>重载;<br>是在一个类里边 方法名字相同 参数不同 返回值可以相同也可以不同<br>参数列表一定改变：可以参数个数顺序或者类型改变<br>重载可以改变修饰符<br>可以声明新的或者更广的异常检查<br>返回类型不可以作为重载的标准</p><p><img src="/2019/05/21/Java/8.png" alt="enter description here"></p><p>总结</p><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><pre><code>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</code></pre><p><img src="/2019/05/21/Java/20171102-1.jpg" alt="enter description here"><br><img src="/2019/05/21/Java/690292-20160923095944481-1758567758.png" alt="enter description here"></p><p>超类=父类=基类<br>子类=派生类</p><p>使用super()调用构造器必须是子类构造器的第一句。<br>子类构造器没有显式调用超类的构造器，自动调用默认的无参构造方法。</p><p>隐式参数：是在类的方法中调用了类的实例域。这个被调用的实例域就是隐式参数。</p><p>public void ariseSalary(double em){<br> double employ = this.salary * em;<br> this.salary += employ;<br>} </p><p>显示参数：就是方法中声明的那些参数</p><p>this 两个用途：1隐式调用参数 2.调用该类其他构造器</p><p>super两个用途：1.调用父类方法   2.调用父类构造器</p><p>Object的equals()方法：<br>子类中定义equals方法时候，先调用超类的equals,检测失败就不可能相等。<br>每个对象都有一个散列码 对应对象的存储地址</p><p>枚举<br>是一个类 有成员变量 有成员方法 构造器（构造器只能private修饰）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列实现原理</title>
      <link href="/2019/05/20/Dqueue/"/>
      <url>/2019/05/20/Dqueue/</url>
      
        <content type="html"><![CDATA[<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列的特点：<br>先进先出<br>队列头删除元素<br>队列尾插入元素</p><p>Java中队列的实现：<br><a id="more"></a><br>1.数组<br>基于数组ArrayDeque<br>ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList。需要注意的是，ArrayDeque不支持null值。<br>在ArrayDeque底层使用了数组来存储数据，同时用两个int值head和tail来表示头部和尾部。不过需要注意的是tail并不是尾部元素的索引，而是尾部元素的下一位，即下一个将要被加入的元素的索引。<br>ArrayDeque中，数组是作为环形来使用的，正常情况下在末尾添加元素后，tail=tail+1是要判断是否越界，如果越界，会变为从索引0开始。参考如下图片，当H添加到索引7后，tail值会+1,此时tail=8，但是越界了，所以应该将tail设置为0。<br>但是为什么这里并没有判断越界呢？关键在于(tail = (tail + 1) &amp; (elements.length - 1)) == head这段代码。这段代码可以拆分为tail = (tail + 1) &amp; (elements.length - 1)和tail == head，这样会比较清晰，前一段代码是为了获取正确的tail索引值，后一段代码是为了判断数组是否满了。之前要求数组的大小必须为2^n值，就是为了能够不通过条件判断，直接使用位操作在环形数组中获取下一个正确的索引值。</p><p>参考链接：<a href="https://www.jianshu.com/p/2f633feda6fb" target="_blank" rel="noopener">https://www.jianshu.com/p/2f633feda6fb</a></p><p>add()源码是基于addLast()实现：<br>offer()基于offerLast（） offerLast()基于addLast();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Inserts the specified element at the end of this deque.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line">  *</span><br><span class="line">  * @param e the element to add</span><br><span class="line">  * @throws NullPointerException if the specified element is null</span><br><span class="line">  */</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">     if (e == null)</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     elements[tail] = e;</span><br><span class="line">     if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">         doubleCapacity();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>remove()基于 removeFirst（）实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * @throws NoSuchElementException &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  public E removeFirst() &#123;</span><br><span class="line">      E x = pollFirst();</span><br><span class="line">      if (x == null)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">      return x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>element()基于getFirst() ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">       E result = (E) elements[head];</span><br><span class="line">       <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>poll()基于pollFirst();</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    int h = head;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    elements[h] = <span class="literal">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek（）基于 peekFirst()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">        // elements[head] is null if deque empty</span><br><span class="line">        return (E) elements[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他基本操作基本逻辑和这两个差不多，主要是对head tail操作。<br>2.链表<br>基于LinkedList实现：<br>offer实际上调用了add（） add()调用linkLast（）队尾追加元素<br>add()操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove（）调用removeFirst（）<br>poll（）调用unlinkFirst（）队首获取元素，获取完移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return the first element from this list</span></span><br><span class="line"><span class="comment">    * @throws NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public E removeFirst() &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">       <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">       final E element = f.item;</span><br><span class="line">       final Node&lt;E&gt; next = f.next;</span><br><span class="line">       f.item = <span class="literal">null</span>;</span><br><span class="line">       f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">       first = next;</span><br><span class="line">       <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">           last = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           next.prev = <span class="literal">null</span>;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>peek()同样可以获取队首元素，但是与poll不同的是并不会将该元素从队列中删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return the head of this list, or &#123;@code null&#125; if this list is empty</span></span><br><span class="line"><span class="comment">   * @since 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">public E peek() &#123;</span><br><span class="line">      final Node&lt;E&gt; f = first;</span><br><span class="line">      <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>element():获取但不删除同peek</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the first element in this list</span></span><br><span class="line"><span class="comment"> * @throws NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer6-7</title>
      <link href="/2019/05/19/offer6/"/>
      <url>/2019/05/19/offer6/</url>
      
        <content type="html"><![CDATA[<h6 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6 旋转数组的最小数字"></a>6 旋转数组的最小数字</h6><p>题目描述：<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a><br>题目解析：<br>本题要求找到数组的最小元素。如果使用暴力方法遍历，时间复杂度是O(n)<br>题目给出的数组是一个旋转数组，算是半有序状态</p><p>1.如果数组是{3,4,5,1,2}这种情况的话：考虑折半查找时间复杂度O(logN);<br>&ensp;&ensp;找到mid mid的值大于heigh 最小元素就在右侧    另一种情况，low对应元素的值小于mid的值 最小元素在左侧<br>2.考虑特殊情况{1,0,1,1,1}与{1,1,1,0,1} mid元素==high元素时候 high–</p><p>伪代码：<br>初始：low=0 high=arr.length-1<br>while(low&lt;high)<br>     mid=low+(high-low)/2<br>     if(arr[mid]&gt;arr[heigh])<br>        low=mid+1<br>    if(arr[mid]==arr[heigh])<br>       high=high-1<br>     else<br>       high=mid<br>return arr[low]</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ; <span class="keyword">int</span> high = array.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;       </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])&#123;</span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7 斐波那契数列"></a>7 斐波那契数列</h6><p>题目描述<br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39<br>题目解析：<br>斐波那契数列：0 1 1 2 3 5 8…<br>1.直接使用递归形式 f(n)=f(n-1)+f(n-2)  这种方式大量重复计算 时间复杂度是指数形式增长<br>2.使用循环递归</p><p>1.直接递归代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br></pre></td></tr></table></figure><p>2.循环递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">         <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        int a=<span class="number">1</span>; int b=<span class="number">0</span>; int fib=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++) &#123; fib=a+b; b=a; a=fib; &#125; </span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 斐波那契数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer5</title>
      <link href="/2019/05/19/offer5/"/>
      <url>/2019/05/19/offer5/</url>
      
        <content type="html"><![CDATA[<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>题目解析：<br>队列的特点：先进先出<br>栈的特点 ：后进先出<br>所以需要两个栈来完成队列的先进先出。对于队列的push,先直接存入栈1。对于POP就需要将栈1的元素弹出，再压入栈2.然后栈2元素弹出。<br><a id="more"></a><br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer4</title>
      <link href="/2019/05/18/Offer4/"/>
      <url>/2019/05/18/Offer4/</url>
      
        <content type="html"><![CDATA[<h5 id="二叉树重建"><a href="#二叉树重建" class="headerlink" title="二叉树重建"></a>二叉树重建</h5><p>1.题目描述：<br>  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a><br>题目解析：<br>前序主要用于：确定根节点<br>中序主要用于：确定属于左右子树<br>所以整个问题就：递归实现构建二叉树。<br>       1.先确定根节点<br>       2.构建左子树—–&gt;找出该左子树的根节点，构建该左字树的左子树，构建该左子树的右子树…..直到序列中没有左子树的序列<br>       3.构建右子树—–&gt;找出该右子树的根节点，构建该右字树的左子树，构建该右子树的右子树…..直到序列中没有右子树的序列<br><img src="/2019/05/18/Offer4/1.JPG" alt="大致思路"></p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">    TreeNode root=reConstructTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode reConstructTree(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd)&#123;</span><br><span class="line">        if(preEnd&lt;preStart||inStart&gt;inEnd)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=new TreeNode(pre[preStart]);</span><br><span class="line">        for(int i=inStart;i&lt;=inEnd;i++)&#123;</span><br><span class="line">            if(pre[preStart]==in[i])&#123;</span><br><span class="line">                root.left=reConstructTree(pre,preStart+1,preStart-inStart+i,in,inStart,i-1);</span><br><span class="line">                root.right=reConstructTree(pre,preStart-inStart+i+1,preEnd,in,i+1,inEnd);</span><br><span class="line">                break;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">         return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized同步方法</title>
      <link href="/2019/05/18/5-18/"/>
      <url>/2019/05/18/5-18/</url>
      
        <content type="html"><![CDATA[<p>&ensp; 非线程安全：多个线程同时对对象中的实例变量进行并发访问时发生。产生的后果是“脏读”。也就是读到的数据是被修改过的。<br>&ensp; 线程安全：获得的实例变量的值是经过同步处理的。</p><h3 id="1-1-方法内的变量是线程安全"><a href="#1-1-方法内的变量是线程安全" class="headerlink" title="1.1 方法内的变量是线程安全"></a>1.1 方法内的变量是线程安全</h3><p>&ensp; 方法内的私有变量，不存在非线程安全问题。是方法内部的变量是私有的特性造成的。<br><a id="more"></a></p><h3 id="1-2-Synchronized"><a href="#1-2-Synchronized" class="headerlink" title="1.2 Synchronized"></a>1.2 Synchronized</h3><p>&ensp;  Synchronized究竟锁住的是什么？锁到底长什么样？<br>&ensp;  锁本身是一个对象，可以是任何一个对象。Synchronized严格意义上是一个加锁操作。真正锁住的是一个对象。<br> &ensp; 互斥的基本条件是：共用一把锁   静态方法的锁是：所在类的Class对象，普通方法索的是this对象。<br>&ensp; Synchronized是可重入锁，可浅显的理解为同一个线程已经持有该锁的情况下可以再次获取锁，并且会在某个状态量上+1.<br>&ensp; 子类同步方法可以调用父类的同步方法吗？<br>&ensp; &ensp; 答案是：可以<br><img src="/2019/05/18/5-18/1.jpg" alt="子类同步方法调用父类同步方法"><br>子类对象初始化前，会调用父类的构造方法，结构上相当于包裹了一个父类对象，用的都是this对象锁。<br>&ensp;静态同步方法与非静态同步方法互斥吗？<br>&ensp; &ensp;不互斥；前边讲了互斥的基本条件是：共用一把锁。这里完全是两个锁。<br><img src="/2019/05/18/5-18/2.jpg" alt="静态同步方法与非静态同步方法"></p><h4 id="大佬通过反编译解释的Synchronized原理"><a href="#大佬通过反编译解释的Synchronized原理" class="headerlink" title="大佬通过反编译解释的Synchronized原理"></a>大佬通过反编译解释的Synchronized原理</h4><p>原博客地址：<a href="http://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5367116.html</a></p><h6 id="对代码块进行同步"><a href="#对代码块进行同步" class="headerlink" title="对代码块进行同步"></a>对代码块进行同步</h6><p>指令monitorenter ：<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。<br>指令monitorexit：<br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p><p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p><p>　　通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>&ensp;&ensp;方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TBBT全剧终</title>
      <link href="/2019/05/18/TBBT/"/>
      <url>/2019/05/18/TBBT/</url>
      
        <content type="html"><![CDATA[<p>   改好了博客新主题，换了一个新的markdown编辑工具。试验一下，顺便记录下与TBBT的六年。<br>       今天第十二季生活大爆炸完结了。2013-2019年。从补之前的几季到中间剧荒反反复复的看。最喜欢的还是S和L陪Amy和Penny逛街那集，两人相互抱怨后相拥哭泣，搞笑、drama又感人。<br>       TBBT有科学，有感动，有搞笑，有温情。今天看了最后一集。Amy在领奖台上说了一番鼓励女性投身科学事业的话真的正能量。Sheldon在领奖台上感谢自已的朋友，用了another family。非常sweety了。当R,B,H,P,L站起来每个人眼睛都是湿润的，不单单是剧情需要……<br>       最后的结尾，大家穿回了第一季的衣服，围坐在茶几前。然后又是那首熟悉的歌，节奏变慢，淡出….<br>       最后的彩蛋还没看。一把年纪，承受不来，只能哪天再看了。</p><p> <img src="/2019/05/18/TBBT/1.jpg" alt="彩蛋图"></p><p>最后推荐一个博主   @生活大爆炸TBBT  (良心字幕组）<br>                    一个Up主:怪盗魔王MagicOne(英语学习博主）</p>]]></content>
      
      
      <categories>
          
          <category> Life&amp;SomethingElse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -美剧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV操作题目</title>
      <link href="/2019/05/17/PV/"/>
      <url>/2019/05/17/PV/</url>
      
        <content type="html"><![CDATA[<p>面试题：写一个固定容量的同步容器</p><p>据说是淘宝？很久以前的一道面试题：</p><pre><code>面试题：写一个固定容量的同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</code></pre><a id="more"></a><p>wait/notifyAll实现：</p><p>public class MyContainer1<t> {<br>    final private LinkedList<t> lists = new LinkedList&lt;&gt;();<br>    final private int MAX = 10; //固定容量,假定最多10个元素<br>    private int count = 0;</t></t></p><pre><code>//put方法public synchronized void put(T t) {    while(lists.size() == MAX) { //想想为什么用while而不是用if？        try {            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    lists.add(t);    ++count;    this.notifyAll(); //通知消费者线程进行消费}    //get方法public synchronized T get() {    T t = null;    while(lists.size() == 0) {        try {            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    t = lists.removeFirst();    count --;    this.notifyAll(); //通知生产者进行生产    return t;}public static void main(String[] args) {    MyContainer1&lt;String&gt; c = new MyContainer1&lt;&gt;();    //启动消费者线程    for(int i=0; i&lt;10; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;5; j++)                               System.out.println(c.get());        }, &quot;c&quot; + i).start();    }    try {        TimeUnit.SECONDS.sleep(2);    } catch (InterruptedException e) {        e.printStackTrace();    }    //启动生产者线程    for(int i=0; i&lt;2; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;25; j++)                               c.put(Thread.currentThread().getName() + &quot; &quot; + j);        }, &quot;p&quot; + i).start();    }}</code></pre><p>对于初学者，这个面试题的难点在于：</p><p>首先，能想到在MyContainer中塞入LinkedList作为容器（因为有removeFirst方法，比较方便）。Java集合体系中，已经提供了足够多的容器，我们如果要模拟自己的容器，一般会选择将现有的容器包装进自己的容器中，而不是去自己实现一个容器。</p><p>其次，wait方法必须配合notifyAll。据说《Effective Java》甚至提出，wait在绝大多数场景下应该伴随着notifyAll而不是notify。因为notify的唤醒是随机，不能确定唤醒的是哪个线程（可能是消费者方，也可能是生产者方）。所以当某个生产者线程生产完第10个商品让出执行权后，下次抢到执行权的可能还是生产者方的其他线程（触发lists.size()==MAX条件），这样全部生产者线程就会等待（在此之前消费者线程也已经全部等待），整个程序就会发生死锁：<br>第⑤步只是举个例子，实际上也有可能是唤醒消费者，因为notify的唤醒是随机的</p><p>如果还是有同学不明白为什么生产者线程最终会全部等待，可以看看下面的例子，虽然不够贴切，但是以我的美术功底，尽力了：</p><p>如果是notifyAll，则会唤醒所有线程，且各个线程抢到执行权的概率是一致的。即使下一次还是生产者线程抢到执行权并且等待了，此时还有其他线程是活着的。</p><p>最后，由于理论上锁可以是任意对象，所以锁的wait/notify/notifyAll等方法就被定义在Object类中，让所有类去继承。如果你仍觉得synchronized才是锁，这个问题是解释不通的。所以，请明确，wait/notify/notifyAll这些方法都是锁对象的方法，线程之所以会产生等待、唤醒等一系列状态，都是去读取锁对象时被指定的。<br>wait<br>notify<br>notifyAll</p><p>最后，提供ReentrantLock实现的版本，更为简单，而且可以精确唤醒生产者线程/消费者线程：</p><p>public class MyContainer2<t> {<br>    final private LinkedList<t> lists = new LinkedList&lt;&gt;();<br>    final private int MAX = 10; //最多10个元素<br>    private int count = 0;</t></t></p><pre><code>private Lock lock = new ReentrantLock();private Condition producer = lock.newCondition();private Condition consumer = lock.newCondition();public void put(T t) {    try {        lock.lock();        while(lists.size() == MAX) { //想想为什么用while而不是用if？            producer.await();        }        lists.add(t);        ++count;        consumer.signalAll(); //通知消费者线程进行消费    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public T get() {    T t = null;    try {        lock.lock();        while(lists.size() == 0) {            consumer.await();        }        t = lists.removeFirst();        count --;        producer.signalAll(); //通知生产者进行生产    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        lock.unlock();    }    return t;}public static void main(String[] args) {    MyContainer2&lt;String&gt; c = new MyContainer2&lt;&gt;();    //启动消费者线程    for(int i=0; i&lt;10; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;5; j++) System.out.println(c.get());        }, &quot;c&quot; + i).start();    }    try {        TimeUnit.SECONDS.sleep(2);    } catch (InterruptedException e) {        e.printStackTrace();    }    //启动生产者线程    for(int i=0; i&lt;2; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;25; j++) c.put(Thread.currentThread().getName() + &quot; &quot; + j);        }, &quot;p&quot; + i).start();    }}</code></pre><p><strong><em>注明：转自知乎大佬 <a href="https://zhuanlan.zhihu.com/p/57482990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57482990</a>   的专栏</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（一）</title>
      <link href="/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>&ensp;线程与进程：<br>&ensp;&ensp;一个进程至少有一个线程。线程是进程的执行单元，是进程内的可调度实体。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>&ensp;Java实现多线程的比较简单两种方式：<br>&ensp;&ensp;1.继承Thread类。<br>&ensp;&ensp;2.实现Runnable接口。<br>&ensp;Java单根继承，不支持多继承。可以实现多个接口。<br>&ensp;一般推荐实现Runnable接口的方式。主要原因可以归结为:<br>    资源和线程分离，更加面向对象;可以做到资源共享</p><hr><p>&ensp;&ensp; <strong>继承Thread类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public class ThreadTest extends Thread&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    System.out.println(&quot;ThreadTest&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">      ThreadTest test=new ThreadTest();</span><br><span class="line">      test.start();</span><br><span class="line">      System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516153705868.png" alt="运行结果图"></p><p>&ensp;&ensp;线程调用的随机性：线程是一个子任务，cpu以一个不确定方式或者以一个随机时间调用线程中的run方法。CPU执行哪个线程具有不确定性。Thread.java类中的start（方法通知“线程规划器”次线程已经准备就绪。等待调用线程对象的run()。这个过程就是让系统安排一个时间来调用Thread中的run()方法。也就是使得线程得到运行。启动线程具有异步效果。如果调用的不是start()而是run()就不是异步执行，而是同步。（线程启动顺序与start()执行顺序无关）此线程不交给线程规划器，而是由主线程调用run()，就是等run()代码执行完，才能执行后面代码。</p><hr><p>&ensp;&ensp; <strong>实现Runnable接口：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ThreadRun implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;Runnable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">      ThreadRun threadTest=new ThreadRun();</span><br><span class="line">      Thread thread=new Thread(threadTest);</span><br><span class="line">      thread.start();</span><br><span class="line">      System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行结果与继承方式一样。<br>&ensp;&ensp;Thread.java类有8个构造函数，其中两个构造函数Thread(Runnable target)和Thread(Runnable target,String name）可以传递Runnable接口，说明参数可以是Runnable接口的对象。Thread.java类也实现了Runnable接口，意味着构造函数不仅可以传入Runnable接口的对象，还可以传入Thread类对象。这样完全可以将一个Thread对象中的run()方法交由其他线程调用。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&ensp;<strong>实例变量与线程安全：</strong><br>&ensp;&ensp;自定义线程间的实例变量：<br>&ensp;&ensp;1.共享数据<br>&ensp;&ensp;2.不共享数据<br>&ensp;<strong>不共享数据例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTheard extends Thread&#123;</span><br><span class="line">private int count=5;</span><br><span class="line">public MyTheard(String name)&#123;</span><br><span class="line">super();</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    while(count&gt;0)&#123;</span><br><span class="line">    count--;   System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot;计算,count&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MyTheard a=new MyTheard(&quot;A&quot;);</span><br><span class="line">MyTheard b=new MyTheard(&quot;B&quot;);</span><br><span class="line">MyTheard c=new MyTheard(&quot;C&quot;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516165957449.png" alt="运行结果"><br>&ensp;&ensp; 此过程创建了三个线程。每个线程有自己的count变量。每个线程在自己的count变量上做操作。这种情况下线程不共享数据。不存在多个线程共享一个实例变量的情况。<br>&ensp;<strong>共享数据的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTheard extends Thread&#123;</span><br><span class="line">private int count=5;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    count--;System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot;计算,count&quot;+count);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MyTheard thread=new MyTheard();</span><br><span class="line">Thread a=new Thread(thread,&quot;A&quot;);</span><br><span class="line">Thread b=new Thread(thread,&quot;B&quot;);</span><br><span class="line">Thread c=new Thread(thread,&quot;C&quot;);</span><br><span class="line">Thread d=new Thread(thread,&quot;D&quot;);</span><br><span class="line">Thread e=new Thread(thread,&quot;E&quot;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">        e.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516170736378.png" alt="运行结果"><br>&ensp;&ensp;分析结果：共享数据的情况就是多个线程访问同一个变量。C,D打印结果都是1，说明CD同时对count做了操作。多个线程同时对同一个变量做操作。一定会出现线程安全问题。这时，就需要线程同步来解决安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于静态帧的行识别</title>
      <link href="/2019/05/02/DL01/"/>
      <url>/2019/05/02/DL01/</url>
      
        <content type="html"><![CDATA[<h6 id="图像表达："><a href="#图像表达：" class="headerlink" title="图像表达："></a>图像表达：</h6><p>特征分类：<br>低层特征：结构简单的监测子得到的特征，表示的是图像边缘以及角点分布信息 Sobel检测子、Canny SIFT<br>中层特征：复杂结构的结构描述 如人体的躯干 车辆的外形 这类方法是基于低层特征的进一步描述 shape context  SPM Poselet<br>高层特征:图像的属性特征，如个体姿态 周围环境 季节 整个算法得到的最后图像描述。<br>以上：人工设计提取特征<br>缺点：针对不同识别任务需要选择不同的特征表达图像 单一特征表达难包含识别所需要的信息  所以很多都采用特征融合<br><a id="more"></a><br>基于深度学习的图像表达技术：<br>深度学习：从大量样本中学到样本包含的统计特性<br>只是将整张图片看做图像分类 效果不好：原因同一个动作的在不同个体上有细微差别 行为中人的姿态与外观是多变的<br>试验了VGG16:发现只是在已有的数据集上效果较好，考虑到数据集 测试集的特征分布不同域问题<br>所以，解决方案可能有：<br>1.重要区域提取，比如说交互区域获取 主要区域获取等      基于目标检测算法<br>2.可能作用不是很大 有待研究   </p>]]></content>
      
      
      <categories>
          
          <category> DL学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer1-2</title>
      <link href="/2019/05/01/%E5%89%91%E6%8C%87Offer/"/>
      <url>/2019/05/01/%E5%89%91%E6%8C%87Offer/</url>
      
        <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>题解：二维数组是从左到右递增，从上到下增。所以用查找目标target与右上角或者左下角元素比较。以右上角为例，如果target大于右上角元素行向下移动，小于列左移。直到超出边界都没找到，返回FALSE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">int col=arra[0].length-1;</span><br><span class="line">int row=0;</span><br><span class="line">while(row&lt;=array.length-1&amp;&amp;col&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">if(target==array[row][col])</span><br><span class="line">return true;</span><br><span class="line">else if(target&gt;array[row][col])</span><br><span class="line">row++;</span><br><span class="line">else</span><br><span class="line">col--;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>题解：需要判断每个字符还不是为空格，不是存到结果是的话，替换为%20存入。</p><pre><code>所以：用StringBuffer格式保存新生成字符串。  可以使用charAt(index)判断每一字符，等于空格，StringBuffer.append(&quot;%20&quot;),否则直接把这个index下的char存入结果。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        StringBuffer newStr=new StringBuffer();</span><br><span class="line">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            if(str.charAt(i)==&apos; &apos;)&#123;</span><br><span class="line">                newStr.append(&quot;%20&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">              newStr.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return newStr.toString();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer3</title>
      <link href="/2019/05/01/%E5%89%91%E6%8C%87Offer3/"/>
      <url>/2019/05/01/%E5%89%91%E6%8C%87Offer3/</url>
      
        <content type="html"><![CDATA[<h5 id="题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"><a href="#题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。" class="headerlink" title="题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"></a>题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</h5><h6 id="思路：原链表1→2→3→4-要求返回：ArrayList-4-3-2-1"><a href="#思路：原链表1→2→3→4-要求返回：ArrayList-4-3-2-1" class="headerlink" title="思路：原链表1→2→3→4  要求返回：ArrayList:{4,3,2,1}"></a>思路：原链表1→2→3→4  要求返回：ArrayList:{4,3,2,1}</h6><p>  1.使用链表反转：链表反转之后 从头遍历存入ArrayList</p><p>  2.使用两个ArrayList:链表从头遍历存入ArrayList，ArrayList反序存入另一个ArrayList</p><p>  3.利用栈的先进后出原则：链表元素入栈，栈元素出栈存入ArrayList</p><h6 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ListNode pre=null;</span><br><span class="line">        ArrayList arr=new ArrayList&lt;&gt;();</span><br><span class="line">        while(listNode!=null)&#123;</span><br><span class="line">          ListNode cur=listNode.next;</span><br><span class="line">          listNode.next=pre;</span><br><span class="line">          pre=listNode;</span><br><span class="line">          listNode=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        while(pre!=null)&#123;</span><br><span class="line">            arr.add(pre.val);</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-两个ArrayList："><a href="#2-两个ArrayList：" class="headerlink" title="2.两个ArrayList："></a>2.两个ArrayList：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">         ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            while (listNode != null) &#123;</span><br><span class="line">                arrayList.add(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">          for(int i=arrayList.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">              result.add(arrayList.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-栈方式"><a href="#3-栈方式" class="headerlink" title="3.栈方式"></a>3.栈方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Stack;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">     </span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">            while (listNode != null) &#123;</span><br><span class="line">                stack.push(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stack.isEmpty()) &#123;</span><br><span class="line">                arrayList.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            return arrayList;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
