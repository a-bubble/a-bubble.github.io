<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指Offer4</title>
      <link href="/2019/05/18/Offer4/"/>
      <url>/2019/05/18/Offer4/</url>
      
        <content type="html"><![CDATA[<h5 id="二叉树重建"><a href="#二叉树重建" class="headerlink" title="二叉树重建"></a>二叉树重建</h5><p>1.题目描述：<br>  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a><br>题目解析：<br>前序主要用于：确定根节点<br>中序主要用于：确定属于左右子树<br>所以整个问题就：递归实现构建二叉树。<br>       1.先确定根节点<br>       2.构建左子树—–&gt;找出该左子树的根节点，构建该左字树的左子树，构建该左子树的右子树…..直到序列中没有左子树的序列<br>       3.构建右子树—–&gt;找出该右子树的根节点，构建该右字树的左子树，构建该右子树的右子树…..直到序列中没有右子树的序列<br><img src="/2019/05/18/Offer4/1.JPG" alt="大致思路"></p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">    TreeNode root=reConstructTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode reConstructTree(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd)&#123;</span><br><span class="line">        if(preEnd&lt;preStart||inStart&gt;inEnd)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=new TreeNode(pre[preStart]);</span><br><span class="line">        for(int i=inStart;i&lt;=inEnd;i++)&#123;</span><br><span class="line">            if(pre[preStart]==in[i])&#123;</span><br><span class="line">                root.left=reConstructTree(pre,preStart+1,preStart-inStart+i,in,inStart,i-1);</span><br><span class="line">                root.right=reConstructTree(pre,preStart-inStart+i+1,preEnd,in,i+1,inEnd);</span><br><span class="line">                break;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">         return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized同步方法</title>
      <link href="/2019/05/18/5-18/"/>
      <url>/2019/05/18/5-18/</url>
      
        <content type="html"><![CDATA[<p>&ensp; 非线程安全：多个线程同时对对象中的实例变量进行并发访问时发生。产生的后果是“脏读”。也就是读到的数据是被修改过的。<br>&ensp; 线程安全：获得的实例变量的值是经过同步处理的。</p><h3 id="1-1-方法内的变量是线程安全"><a href="#1-1-方法内的变量是线程安全" class="headerlink" title="1.1 方法内的变量是线程安全"></a>1.1 方法内的变量是线程安全</h3><p>&ensp; 方法内的私有变量，不存在非线程安全问题。是方法内部的变量是私有的特性造成的。<br><a id="more"></a></p><h3 id="1-2-Synchronized"><a href="#1-2-Synchronized" class="headerlink" title="1.2 Synchronized"></a>1.2 Synchronized</h3><p>&ensp;  Synchronized究竟锁住的是什么？锁到底长什么样？<br>&ensp;  锁本身是一个对象，可以是任何一个对象。Synchronized严格意义上是一个加锁操作。真正锁住的是一个对象。<br> &ensp; 互斥的基本条件是：共用一把锁   静态方法的锁是：所在类的Class对象，普通方法索的是this对象。<br>&ensp; Synchronized是可重入锁，可浅显的理解为同一个线程已经持有该锁的情况下可以再次获取锁，并且会在某个状态量上+1.<br>&ensp; 子类同步方法可以调用父类的同步方法吗？<br>&ensp; &ensp; 答案是：可以<br><img src="/2019/05/18/5-18/1.jpg" alt="子类同步方法调用父类同步方法"><br>子类对象初始化前，会调用父类的构造方法，结构上相当于包裹了一个父类对象，用的都是this对象锁。<br>&ensp;静态同步方法与非静态同步方法互斥吗？<br>&ensp; &ensp;不互斥；前边讲了互斥的基本条件是：共用一把锁。这里完全是两个锁。<br><img src="/2019/05/18/5-18/2.jpg" alt="静态同步方法与非静态同步方法"></p><h4 id="大佬通过反编译解释的Synchronized原理"><a href="#大佬通过反编译解释的Synchronized原理" class="headerlink" title="大佬通过反编译解释的Synchronized原理"></a>大佬通过反编译解释的Synchronized原理</h4><p>原博客地址：<a href="http://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5367116.html</a></p><h6 id="对代码块进行同步"><a href="#对代码块进行同步" class="headerlink" title="对代码块进行同步"></a>对代码块进行同步</h6><p>指令monitorenter ：<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。<br>指令monitorexit：<br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p><p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p><p>　　通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>&ensp;&ensp;方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TBBT全剧终</title>
      <link href="/2019/05/18/TBBT/"/>
      <url>/2019/05/18/TBBT/</url>
      
        <content type="html"><![CDATA[<p>   改好了博客新主题，换了一个新的markdown编辑工具。试验一下，顺便记录下与TBBT的六年。<br>       今天第十二季生活大爆炸完结了。2013-2019年。从补之前的几季到中间剧荒反反复复的看。最喜欢的还是S和L陪Amy和Penny逛街那集，两人相互抱怨后相拥哭泣，搞笑、drama又感人。<br>       TBBT有科学，有感动，有搞笑，有温情。今天看了最后一集。Amy在领奖台上说了一番鼓励女性投身科学事业的话真的正能量。Sheldon在领奖台上感谢自已的朋友，用了another family。非常sweety了。当R,B,H,P,L站起来每个人眼睛都是湿润的，不单单是剧情需要……<br>       最后的结尾，大家穿回了第一季的衣服，围坐在茶几前。然后又是那首熟悉的歌，节奏变慢，淡出….<br>       最后的彩蛋还没看。一把年纪，承受不来，只能哪天再看了。</p><p> <img src="/2019/05/18/TBBT/1.jpg" alt="彩蛋图"></p><p>最后推荐一个博主   @生活大爆炸TBBT  (良心字幕组）<br>                    一个Up主:怪盗魔王MagicOne(英语学习博主）</p>]]></content>
      
      
      <categories>
          
          <category> Life&amp;SomethingElse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -美剧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV操作题目</title>
      <link href="/2019/05/17/PV/"/>
      <url>/2019/05/17/PV/</url>
      
        <content type="html"><![CDATA[<p>面试题：写一个固定容量的同步容器</p><p>据说是淘宝？很久以前的一道面试题：</p><pre><code>面试题：写一个固定容量的同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</code></pre><a id="more"></a><p>wait/notifyAll实现：</p><p>public class MyContainer1<t> {<br>    final private LinkedList<t> lists = new LinkedList&lt;&gt;();<br>    final private int MAX = 10; //固定容量,假定最多10个元素<br>    private int count = 0;</t></t></p><pre><code>//put方法public synchronized void put(T t) {    while(lists.size() == MAX) { //想想为什么用while而不是用if？        try {            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    lists.add(t);    ++count;    this.notifyAll(); //通知消费者线程进行消费}    //get方法public synchronized T get() {    T t = null;    while(lists.size() == 0) {        try {            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    t = lists.removeFirst();    count --;    this.notifyAll(); //通知生产者进行生产    return t;}public static void main(String[] args) {    MyContainer1&lt;String&gt; c = new MyContainer1&lt;&gt;();    //启动消费者线程    for(int i=0; i&lt;10; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;5; j++)                               System.out.println(c.get());        }, &quot;c&quot; + i).start();    }    try {        TimeUnit.SECONDS.sleep(2);    } catch (InterruptedException e) {        e.printStackTrace();    }    //启动生产者线程    for(int i=0; i&lt;2; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;25; j++)                               c.put(Thread.currentThread().getName() + &quot; &quot; + j);        }, &quot;p&quot; + i).start();    }}</code></pre><p>对于初学者，这个面试题的难点在于：</p><p>首先，能想到在MyContainer中塞入LinkedList作为容器（因为有removeFirst方法，比较方便）。Java集合体系中，已经提供了足够多的容器，我们如果要模拟自己的容器，一般会选择将现有的容器包装进自己的容器中，而不是去自己实现一个容器。</p><p>其次，wait方法必须配合notifyAll。据说《Effective Java》甚至提出，wait在绝大多数场景下应该伴随着notifyAll而不是notify。因为notify的唤醒是随机，不能确定唤醒的是哪个线程（可能是消费者方，也可能是生产者方）。所以当某个生产者线程生产完第10个商品让出执行权后，下次抢到执行权的可能还是生产者方的其他线程（触发lists.size()==MAX条件），这样全部生产者线程就会等待（在此之前消费者线程也已经全部等待），整个程序就会发生死锁：<br>第⑤步只是举个例子，实际上也有可能是唤醒消费者，因为notify的唤醒是随机的</p><p>如果还是有同学不明白为什么生产者线程最终会全部等待，可以看看下面的例子，虽然不够贴切，但是以我的美术功底，尽力了：</p><p>如果是notifyAll，则会唤醒所有线程，且各个线程抢到执行权的概率是一致的。即使下一次还是生产者线程抢到执行权并且等待了，此时还有其他线程是活着的。</p><p>最后，由于理论上锁可以是任意对象，所以锁的wait/notify/notifyAll等方法就被定义在Object类中，让所有类去继承。如果你仍觉得synchronized才是锁，这个问题是解释不通的。所以，请明确，wait/notify/notifyAll这些方法都是锁对象的方法，线程之所以会产生等待、唤醒等一系列状态，都是去读取锁对象时被指定的。<br>wait<br>notify<br>notifyAll</p><p>最后，提供ReentrantLock实现的版本，更为简单，而且可以精确唤醒生产者线程/消费者线程：</p><p>public class MyContainer2<t> {<br>    final private LinkedList<t> lists = new LinkedList&lt;&gt;();<br>    final private int MAX = 10; //最多10个元素<br>    private int count = 0;</t></t></p><pre><code>private Lock lock = new ReentrantLock();private Condition producer = lock.newCondition();private Condition consumer = lock.newCondition();public void put(T t) {    try {        lock.lock();        while(lists.size() == MAX) { //想想为什么用while而不是用if？            producer.await();        }        lists.add(t);        ++count;        consumer.signalAll(); //通知消费者线程进行消费    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public T get() {    T t = null;    try {        lock.lock();        while(lists.size() == 0) {            consumer.await();        }        t = lists.removeFirst();        count --;        producer.signalAll(); //通知生产者进行生产    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        lock.unlock();    }    return t;}public static void main(String[] args) {    MyContainer2&lt;String&gt; c = new MyContainer2&lt;&gt;();    //启动消费者线程    for(int i=0; i&lt;10; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;5; j++) System.out.println(c.get());        }, &quot;c&quot; + i).start();    }    try {        TimeUnit.SECONDS.sleep(2);    } catch (InterruptedException e) {        e.printStackTrace();    }    //启动生产者线程    for(int i=0; i&lt;2; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;25; j++) c.put(Thread.currentThread().getName() + &quot; &quot; + j);        }, &quot;p&quot; + i).start();    }}</code></pre><p><strong><em>注明：转自知乎大佬 <a href="https://zhuanlan.zhihu.com/p/57482990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57482990</a>   的专栏</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（一）</title>
      <link href="/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>&ensp;线程与进程：<br>&ensp;&ensp;一个进程至少有一个线程。线程是进程的执行单元，是进程内的可调度实体。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>&ensp;Java实现多线程的比较简单两种方式：<br>&ensp;&ensp;1.继承Thread类。<br>&ensp;&ensp;2.实现Runnable接口。<br>&ensp;Java单根继承，不支持多继承。可以实现多个接口。<br>&ensp;一般推荐实现Runnable接口的方式。主要原因可以归结为:<br>    资源和线程分离，更加面向对象;可以做到资源共享</p><hr><p>&ensp;&ensp; <strong>继承Thread类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public class ThreadTest extends Thread&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    System.out.println(&quot;ThreadTest&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">      ThreadTest test=new ThreadTest();</span><br><span class="line">      test.start();</span><br><span class="line">      System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516153705868.png" alt="运行结果图"></p><p>&ensp;&ensp;线程调用的随机性：线程是一个子任务，cpu以一个不确定方式或者以一个随机时间调用线程中的run方法。CPU执行哪个线程具有不确定性。Thread.java类中的start（方法通知“线程规划器”次线程已经准备就绪。等待调用线程对象的run()。这个过程就是让系统安排一个时间来调用Thread中的run()方法。也就是使得线程得到运行。启动线程具有异步效果。如果调用的不是start()而是run()就不是异步执行，而是同步。（线程启动顺序与start()执行顺序无关）此线程不交给线程规划器，而是由主线程调用run()，就是等run()代码执行完，才能执行后面代码。</p><hr><p>&ensp;&ensp; <strong>实现Runnable接口：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ThreadRun implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;Runnable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">      ThreadRun threadTest=new ThreadRun();</span><br><span class="line">      Thread thread=new Thread(threadTest);</span><br><span class="line">      thread.start();</span><br><span class="line">      System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行结果与继承方式一样。<br>&ensp;&ensp;Thread.java类有8个构造函数，其中两个构造函数Thread(Runnable target)和Thread(Runnable target,String name）可以传递Runnable接口，说明参数可以是Runnable接口的对象。Thread.java类也实现了Runnable接口，意味着构造函数不仅可以传入Runnable接口的对象，还可以传入Thread类对象。这样完全可以将一个Thread对象中的run()方法交由其他线程调用。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&ensp;<strong>实例变量与线程安全：</strong><br>&ensp;&ensp;自定义线程间的实例变量：<br>&ensp;&ensp;1.共享数据<br>&ensp;&ensp;2.不共享数据<br>&ensp;<strong>不共享数据例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTheard extends Thread&#123;</span><br><span class="line">private int count=5;</span><br><span class="line">public MyTheard(String name)&#123;</span><br><span class="line">super();</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    while(count&gt;0)&#123;</span><br><span class="line">    count--;   System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot;计算,count&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MyTheard a=new MyTheard(&quot;A&quot;);</span><br><span class="line">MyTheard b=new MyTheard(&quot;B&quot;);</span><br><span class="line">MyTheard c=new MyTheard(&quot;C&quot;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516165957449.png" alt="运行结果"><br>&ensp;&ensp; 此过程创建了三个线程。每个线程有自己的count变量。每个线程在自己的count变量上做操作。这种情况下线程不共享数据。不存在多个线程共享一个实例变量的情况。<br>&ensp;<strong>共享数据的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTheard extends Thread&#123;</span><br><span class="line">private int count=5;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    count--;System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot;计算,count&quot;+count);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MyTheard thread=new MyTheard();</span><br><span class="line">Thread a=new Thread(thread,&quot;A&quot;);</span><br><span class="line">Thread b=new Thread(thread,&quot;B&quot;);</span><br><span class="line">Thread c=new Thread(thread,&quot;C&quot;);</span><br><span class="line">Thread d=new Thread(thread,&quot;D&quot;);</span><br><span class="line">Thread e=new Thread(thread,&quot;E&quot;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">        e.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516170736378.png" alt="运行结果"><br>&ensp;&ensp;分析结果：共享数据的情况就是多个线程访问同一个变量。C,D打印结果都是1，说明CD同时对count做了操作。多个线程同时对同一个变量做操作。一定会出现线程安全问题。这时，就需要线程同步来解决安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer1-2</title>
      <link href="/2019/05/01/%E5%89%91%E6%8C%87Offer/"/>
      <url>/2019/05/01/%E5%89%91%E6%8C%87Offer/</url>
      
        <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>题解：二维数组是从左到右递增，从上到下增。所以用查找目标target与右上角或者左下角元素比较。以右上角为例，如果target大于右上角元素行向下移动，小于列左移。直到超出边界都没找到，返回FALSE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">int col=arra[0].length-1;</span><br><span class="line">int row=0;</span><br><span class="line">while(row&lt;=array.length-1&amp;&amp;col&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">if(target==array[row][col])</span><br><span class="line">return true;</span><br><span class="line">else if(target&gt;array[row][col])</span><br><span class="line">row++;</span><br><span class="line">else</span><br><span class="line">col--;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>题解：需要判断每个字符还不是为空格，不是存到结果是的话，替换为%20存入。</p><pre><code>所以：用StringBuffer格式保存新生成字符串。  可以使用charAt(index)判断每一字符，等于空格，StringBuffer.append(&quot;%20&quot;),否则直接把这个index下的char存入结果。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        StringBuffer newStr=new StringBuffer();</span><br><span class="line">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            if(str.charAt(i)==&apos; &apos;)&#123;</span><br><span class="line">                newStr.append(&quot;%20&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">              newStr.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return newStr.toString();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer3</title>
      <link href="/2019/05/01/%E5%89%91%E6%8C%87Offer3/"/>
      <url>/2019/05/01/%E5%89%91%E6%8C%87Offer3/</url>
      
        <content type="html"><![CDATA[<h5 id="题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"><a href="#题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。" class="headerlink" title="题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"></a>题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</h5><h6 id="思路：原链表1→2→3→4-要求返回：ArrayList-4-3-2-1"><a href="#思路：原链表1→2→3→4-要求返回：ArrayList-4-3-2-1" class="headerlink" title="思路：原链表1→2→3→4  要求返回：ArrayList:{4,3,2,1}"></a>思路：原链表1→2→3→4  要求返回：ArrayList:{4,3,2,1}</h6><p>  1.使用链表反转：链表反转之后 从头遍历存入ArrayList</p><p>  2.使用两个ArrayList:链表从头遍历存入ArrayList，ArrayList反序存入另一个ArrayList</p><p>  3.利用栈的先进后出原则：链表元素入栈，栈元素出栈存入ArrayList</p><h6 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ListNode pre=null;</span><br><span class="line">        ArrayList arr=new ArrayList&lt;&gt;();</span><br><span class="line">        while(listNode!=null)&#123;</span><br><span class="line">          ListNode cur=listNode.next;</span><br><span class="line">          listNode.next=pre;</span><br><span class="line">          pre=listNode;</span><br><span class="line">          listNode=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        while(pre!=null)&#123;</span><br><span class="line">            arr.add(pre.val);</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-两个ArrayList："><a href="#2-两个ArrayList：" class="headerlink" title="2.两个ArrayList："></a>2.两个ArrayList：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">         ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            while (listNode != null) &#123;</span><br><span class="line">                arrayList.add(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">          for(int i=arrayList.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">              result.add(arrayList.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-栈方式"><a href="#3-栈方式" class="headerlink" title="3.栈方式"></a>3.栈方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Stack;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">     </span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">            while (listNode != null) &#123;</span><br><span class="line">                stack.push(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stack.isEmpty()) &#123;</span><br><span class="line">                arrayList.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            return arrayList;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
