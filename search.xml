<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>剑指offer8-9</title>
      <link href="/2019/05/27/offer8/"/>
      <url>/2019/05/27/offer8/</url>
      
        <content type="html"><![CDATA[<h6 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h6><p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><a id="more"></a><br>分析：<br>1.如果只有1级台阶，那显然只有一种跳法<br>2.如果有2级台阶，那么就有2种跳法，一种是分2次跳。每次跳1级，另一种就是一次跳2级<br>3.如果台阶级数大于2，设为n的话，这时我们把n级台阶时的跳法看成n的函数，记为,第一次跳的时候有2种不同的选择：一是第一次跳一级，此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，即为f(n-1)二是第一次跳二级，此时跳法的数目等于后面剩下的n-2级台阶的跳法数目，即为f(n-2),因此n级台阶的不同跳法的总数为f(n)=f(n-1)+f(n-2) 是斐波那契数列。<br>如果使用递归的方式的话吗，如果要求f(9)要求f(8)+f(7)求f(8)又要求f(7)+f(6)所以，存在重复计算<br>使用循环的方式，就是从下往上计算，时间复杂度O(n)<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if(target==2)</span><br><span class="line">            return 2;</span><br><span class="line">        if(target==1)</span><br><span class="line">            return 1;</span><br><span class="line">        int count=0;int n1=1; int n2=2;</span><br><span class="line">        for(int i=3;i&lt;=target;i++)&#123;</span><br><span class="line">            count=n1+n2;</span><br><span class="line">            n1=n2;</span><br><span class="line">            n2=count;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h6><p>题目描述<br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>解析：<br>f(0) = 1<br>f(1) = 1<br>f(2) = f(2-1)+f(2-1) #跳一步回到f(1)问题，跳两步回到f(0)问题<br>f(3) = f(3-1)+f(3-2)+f(3-3)<br>…<br>f(n-1) = f((n-1)-1)+f((n-1)-2)+…+f((n-1)-(n-1)) = f(n-2)+f(n-3)+…+f(0) #注意我高亮的部分<br>f(n) = f(n-1)+f(n-2)+f(n-3)…+f(0) = f(n-1)+f(n-1) = 2*f(n-1) </p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2019/05/21/Java/"/>
      <url>/2019/05/21/Java/</url>
      
        <content type="html"><![CDATA[<h6 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h6><ol><li>数值类型之间转换<br><img src="/2019/05/21/Java/1.png" alt="enter description here"></li></ol><p>2.字符串判断</p><p><img src="/2019/05/21/Java/2.png" alt="enter description here"></p><p>3.数组拷贝<br><img src="/2019/05/21/Java/3.png" alt="enter description here"></p><p>4.构造器<br><img src="/2019/05/21/Java/4.png" alt="enter description here"></p><p>5.静态方法<br><img src="/2019/05/21/Java/5.png" alt="enter description here"></p><p>6.参数值<br><img src="/2019/05/21/Java/6.png" alt="enter description here"></p><p>7<img src="/2019/05/21/Java/7.png" alt="enter description here"></p><p>8.重载与重写：<br>重写也叫 覆盖 ：子类对父类方法的修改。<br>参数列表与被重写参数列表完全一致。<br>返回类型可以与父类不一样 但是必须属于其派生类型<br>访问权限不能比父类的低<br>声明为final的方法不能重写<br>声明为static 的方法不能被重写 但是可以被声明<br>子类与父类在同一个包里 子类可以重写除了final static外所有方法<br>不在一个包里 只能重写public protected<br>构造方法不能被重写<br>子类中调用父类的被重写方法时，要使用super关键字。 </p><p>重载;<br>是在一个类里边 方法名字相同 参数不同 返回值可以相同也可以不同<br>参数列表一定改变：可以参数个数顺序或者类型改变<br>重载可以改变修饰符<br>可以声明新的或者更广的异常检查<br>返回类型不可以作为重载的标准</p><p><img src="/2019/05/21/Java/8.png" alt="enter description here"></p><p>总结</p><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><pre><code>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</code></pre><p><img src="/2019/05/21/Java/20171102-1.jpg" alt="enter description here"><br><img src="/2019/05/21/Java/690292-20160923095944481-1758567758.png" alt="enter description here"></p><p>超类=父类=基类<br>子类=派生类</p><p>使用super()调用构造器必须是子类构造器的第一句。<br>子类构造器没有显式调用超类的构造器，自动调用默认的无参构造方法。</p><p>隐式参数：是在类的方法中调用了类的实例域。这个被调用的实例域就是隐式参数。</p><p>public void ariseSalary(double em){<br> double employ = this.salary * em;<br> this.salary += employ;<br>} </p><p>显示参数：就是方法中声明的那些参数</p><p>this 两个用途：1隐式调用参数 2.调用该类其他构造器</p><p>super两个用途：1.调用父类方法   2.调用父类构造器</p><p>Object的equals()方法：<br>子类中定义equals方法时候，先调用超类的equals,检测失败就不可能相等。<br>每个对象都有一个散列码 对应对象的存储地址</p><p>枚举<br>是一个类 有成员变量 有成员方法 构造器（构造器只能private修饰）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列实现原理</title>
      <link href="/2019/05/20/Dqueue/"/>
      <url>/2019/05/20/Dqueue/</url>
      
        <content type="html"><![CDATA[<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>队列的特点：<br>先进先出<br>队列头删除元素<br>队列尾插入元素</p><p>Java中队列的实现：<br><a id="more"></a><br>1.数组<br>基于数组ArrayDeque<br>ArrayDeque是Deque接口的一个实现，使用了可变数组，所以没有容量上的限制。同时，ArrayDeque是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。ArrayDeque是Deque的实现类，可以作为栈来使用，效率高于Stack；也可以作为队列来使用，效率高于LinkedList。需要注意的是，ArrayDeque不支持null值。<br>在ArrayDeque底层使用了数组来存储数据，同时用两个int值head和tail来表示头部和尾部。不过需要注意的是tail并不是尾部元素的索引，而是尾部元素的下一位，即下一个将要被加入的元素的索引。<br>ArrayDeque中，数组是作为环形来使用的，正常情况下在末尾添加元素后，tail=tail+1是要判断是否越界，如果越界，会变为从索引0开始。参考如下图片，当H添加到索引7后，tail值会+1,此时tail=8，但是越界了，所以应该将tail设置为0。<br>但是为什么这里并没有判断越界呢？关键在于(tail = (tail + 1) &amp; (elements.length - 1)) == head这段代码。这段代码可以拆分为tail = (tail + 1) &amp; (elements.length - 1)和tail == head，这样会比较清晰，前一段代码是为了获取正确的tail索引值，后一段代码是为了判断数组是否满了。之前要求数组的大小必须为2^n值，就是为了能够不通过条件判断，直接使用位操作在环形数组中获取下一个正确的索引值。</p><p>参考链接：<a href="https://www.jianshu.com/p/2f633feda6fb" target="_blank" rel="noopener">https://www.jianshu.com/p/2f633feda6fb</a></p><p>add()源码是基于addLast()实现：<br>offer()基于offerLast（） offerLast()基于addLast();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Inserts the specified element at the end of this deque.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;This method is equivalent to &#123;@link #add&#125;.</span><br><span class="line">  *</span><br><span class="line">  * @param e the element to add</span><br><span class="line">  * @throws NullPointerException if the specified element is null</span><br><span class="line">  */</span><br><span class="line"> public void addLast(E e) &#123;</span><br><span class="line">     if (e == null)</span><br><span class="line">         throw new NullPointerException();</span><br><span class="line">     elements[tail] = e;</span><br><span class="line">     if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head)</span><br><span class="line">         doubleCapacity();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>remove()基于 removeFirst（）实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * @throws NoSuchElementException &#123;@inheritDoc&#125;</span><br><span class="line">   */</span><br><span class="line">  public E removeFirst() &#123;</span><br><span class="line">      E x = pollFirst();</span><br><span class="line">      if (x == null)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">      return x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>element()基于getFirst() ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">       @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">       E result = (E) elements[head];</span><br><span class="line">       <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>poll()基于pollFirst();</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public E pollFirst() &#123;</span><br><span class="line">    int h = head;</span><br><span class="line">    @SuppressWarnings(<span class="string">"unchecked"</span>)</span><br><span class="line">    E result = (E) elements[h];</span><br><span class="line">    <span class="comment">// Element is null if deque empty</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    elements[h] = <span class="literal">null</span>;     <span class="comment">// Must null out slot</span></span><br><span class="line">    head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek（）基于 peekFirst()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">        // elements[head] is null if deque empty</span><br><span class="line">        return (E) elements[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他基本操作基本逻辑和这两个差不多，主要是对head tail操作。<br>2.链表<br>基于LinkedList实现：<br>offer实际上调用了add（） add()调用linkLast（）队尾追加元素<br>add()操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove（）调用removeFirst（）<br>poll（）调用unlinkFirst（）队首获取元素，获取完移除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Removes and returns the first element from this list.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return the first element from this list</span></span><br><span class="line"><span class="comment">    * @throws NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   public E removeFirst() &#123;</span><br><span class="line">       final Node&lt;E&gt; f = first;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">       <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Unlinks non-null first node f.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">       <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">       final E element = f.item;</span><br><span class="line">       final Node&lt;E&gt; next = f.next;</span><br><span class="line">       f.item = <span class="literal">null</span>;</span><br><span class="line">       f.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">       first = next;</span><br><span class="line">       <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">           last = <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           next.prev = <span class="literal">null</span>;</span><br><span class="line">       size--;</span><br><span class="line">       modCount++;</span><br><span class="line">       <span class="keyword">return</span> element;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>peek()同样可以获取队首元素，但是与poll不同的是并不会将该元素从队列中删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Retrieves, but does not remove, the head (first element) of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @return the head of this list, or &#123;@code null&#125; if this list is empty</span></span><br><span class="line"><span class="comment">   * @since 1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">public E peek() &#123;</span><br><span class="line">      final Node&lt;E&gt; f = first;</span><br><span class="line">      <span class="keyword">return</span> (f == <span class="literal">null</span>) ? <span class="literal">null</span> : f.item;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>element():获取但不删除同peek</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the first element in this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return the first element in this list</span></span><br><span class="line"><span class="comment"> * @throws NoSuchElementException if this list is empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public E getFirst() &#123;</span><br><span class="line">    final Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer6-7</title>
      <link href="/2019/05/19/offer6/"/>
      <url>/2019/05/19/offer6/</url>
      
        <content type="html"><![CDATA[<h6 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6 旋转数组的最小数字"></a>6 旋转数组的最小数字</h6><p>题目描述：<br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><a id="more"></a><br>题目解析：<br>本题要求找到数组的最小元素。如果使用暴力方法遍历，时间复杂度是O(n)<br>题目给出的数组是一个旋转数组，算是半有序状态</p><p>1.如果数组是{3,4,5,1,2}这种情况的话：考虑折半查找时间复杂度O(logN);<br>&ensp;&ensp;找到mid mid的值大于heigh 最小元素就在右侧    另一种情况，low对应元素的值小于mid的值 最小元素在左侧<br>2.考虑特殊情况{1,0,1,1,1}与{1,1,1,0,1} mid元素==high元素时候 high–</p><p>伪代码：<br>初始：low=0 high=arr.length-1<br>while(low&lt;high)<br>     mid=low+(high-low)/2<br>     if(arr[mid]&gt;arr[heigh])<br>        low=mid+1<br>    if(arr[mid]==arr[heigh])<br>       high=high-1<br>     else<br>       high=mid<br>return arr[low]</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span> ; <span class="keyword">int</span> high = array.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;       </span><br><span class="line">            <span class="keyword">if</span>(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[high])&#123;</span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7 斐波那契数列"></a>7 斐波那契数列</h6><p>题目描述<br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;=39<br>题目解析：<br>斐波那契数列：0 1 1 2 3 5 8…<br>1.直接使用递归形式 f(n)=f(n-1)+f(n-2)  这种方式大量重复计算 时间复杂度是指数形式增长<br>2.使用循环递归</p><p>1.直接递归代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br></pre></td></tr></table></figure><p>2.循环递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">         <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        int a=<span class="number">1</span>; int b=<span class="number">0</span>; int fib=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int i=<span class="number">2</span>;i&lt;=n;i++) &#123; fib=a+b; b=a; a=fib; &#125; </span><br><span class="line">        <span class="keyword">return</span> fib;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 斐波那契数列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer5</title>
      <link href="/2019/05/19/offer5/"/>
      <url>/2019/05/19/offer5/</url>
      
        <content type="html"><![CDATA[<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p>题目描述<br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>题目解析：<br>队列的特点：先进先出<br>栈的特点 ：后进先出<br>所以需要两个栈来完成队列的先进先出。对于队列的push,先直接存入栈1。对于POP就需要将栈1的元素弹出，再压入栈2.然后栈2元素弹出。<br><a id="more"></a><br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer4</title>
      <link href="/2019/05/18/Offer4/"/>
      <url>/2019/05/18/Offer4/</url>
      
        <content type="html"><![CDATA[<h5 id="二叉树重建"><a href="#二叉树重建" class="headerlink" title="二叉树重建"></a>二叉树重建</h5><p>1.题目描述：<br>  输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><a id="more"></a><br>题目解析：<br>前序主要用于：确定根节点<br>中序主要用于：确定属于左右子树<br>所以整个问题就：递归实现构建二叉树。<br>       1.先确定根节点<br>       2.构建左子树—–&gt;找出该左子树的根节点，构建该左字树的左子树，构建该左子树的右子树…..直到序列中没有左子树的序列<br>       3.构建右子树—–&gt;找出该右子树的根节点，构建该右字树的左子树，构建该右子树的右子树…..直到序列中没有右子树的序列<br><img src="/2019/05/18/Offer4/1.JPG" alt="大致思路"></p><p>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">    TreeNode root=reConstructTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public TreeNode reConstructTree(int[] pre,int preStart,int preEnd,int[] in,int inStart,int inEnd)&#123;</span><br><span class="line">        if(preEnd&lt;preStart||inStart&gt;inEnd)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=new TreeNode(pre[preStart]);</span><br><span class="line">        for(int i=inStart;i&lt;=inEnd;i++)&#123;</span><br><span class="line">            if(pre[preStart]==in[i])&#123;</span><br><span class="line">                root.left=reConstructTree(pre,preStart+1,preStart-inStart+i,in,inStart,i-1);</span><br><span class="line">                root.right=reConstructTree(pre,preStart-inStart+i+1,preEnd,in,i+1,inEnd);</span><br><span class="line">                break;</span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;</span><br><span class="line">         return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized同步方法</title>
      <link href="/2019/05/18/5-18/"/>
      <url>/2019/05/18/5-18/</url>
      
        <content type="html"><![CDATA[<p>&ensp; 非线程安全：多个线程同时对对象中的实例变量进行并发访问时发生。产生的后果是“脏读”。也就是读到的数据是被修改过的。<br>&ensp; 线程安全：获得的实例变量的值是经过同步处理的。</p><h3 id="1-1-方法内的变量是线程安全"><a href="#1-1-方法内的变量是线程安全" class="headerlink" title="1.1 方法内的变量是线程安全"></a>1.1 方法内的变量是线程安全</h3><p>&ensp; 方法内的私有变量，不存在非线程安全问题。是方法内部的变量是私有的特性造成的。<br><a id="more"></a></p><h3 id="1-2-Synchronized"><a href="#1-2-Synchronized" class="headerlink" title="1.2 Synchronized"></a>1.2 Synchronized</h3><p>&ensp;  Synchronized究竟锁住的是什么？锁到底长什么样？<br>&ensp;  锁本身是一个对象，可以是任何一个对象。Synchronized严格意义上是一个加锁操作。真正锁住的是一个对象。<br> &ensp; 互斥的基本条件是：共用一把锁   静态方法的锁是：所在类的Class对象，普通方法索的是this对象。<br>&ensp; Synchronized是可重入锁，可浅显的理解为同一个线程已经持有该锁的情况下可以再次获取锁，并且会在某个状态量上+1.<br>&ensp; 子类同步方法可以调用父类的同步方法吗？<br>&ensp; &ensp; 答案是：可以<br><img src="/2019/05/18/5-18/1.jpg" alt="子类同步方法调用父类同步方法"><br>子类对象初始化前，会调用父类的构造方法，结构上相当于包裹了一个父类对象，用的都是this对象锁。<br>&ensp;静态同步方法与非静态同步方法互斥吗？<br>&ensp; &ensp;不互斥；前边讲了互斥的基本条件是：共用一把锁。这里完全是两个锁。<br><img src="/2019/05/18/5-18/2.jpg" alt="静态同步方法与非静态同步方法"></p><h4 id="大佬通过反编译解释的Synchronized原理"><a href="#大佬通过反编译解释的Synchronized原理" class="headerlink" title="大佬通过反编译解释的Synchronized原理"></a>大佬通过反编译解释的Synchronized原理</h4><p>原博客地址：<a href="http://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">http://www.cnblogs.com/paddix/p/5367116.html</a></p><h6 id="对代码块进行同步"><a href="#对代码块进行同步" class="headerlink" title="对代码块进行同步"></a>对代码块进行同步</h6><p>指令monitorenter ：<br>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</p><p>1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</p><p>2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</p><p>3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。<br>指令monitorexit：<br>执行monitorexit的线程必须是objectref所对应的monitor的所有者。</p><p>指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 </p><p>　　通过这两段描述，我们应该能很清楚的看出Synchronized的实现原理，Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。</p><h5 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h5><p>&ensp;&ensp;方法的同步并没有通过指令monitorenter和monitorexit来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。JVM就是根据该标示符来实现方法的同步的：当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 其实本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TBBT全剧终</title>
      <link href="/2019/05/18/TBBT/"/>
      <url>/2019/05/18/TBBT/</url>
      
        <content type="html"><![CDATA[<p>   改好了博客新主题，换了一个新的markdown编辑工具。试验一下，顺便记录下与TBBT的六年。<br>       今天第十二季生活大爆炸完结了。2013-2019年。从补之前的几季到中间剧荒反反复复的看。最喜欢的还是S和L陪Amy和Penny逛街那集，两人相互抱怨后相拥哭泣，搞笑、drama又感人。<br>       TBBT有科学，有感动，有搞笑，有温情。今天看了最后一集。Amy在领奖台上说了一番鼓励女性投身科学事业的话真的正能量。Sheldon在领奖台上感谢自已的朋友，用了another family。非常sweety了。当R,B,H,P,L站起来每个人眼睛都是湿润的，不单单是剧情需要……<br>       最后的结尾，大家穿回了第一季的衣服，围坐在茶几前。然后又是那首熟悉的歌，节奏变慢，淡出….<br>       最后的彩蛋还没看。一把年纪，承受不来，只能哪天再看了。</p><p> <img src="/2019/05/18/TBBT/1.jpg" alt="彩蛋图"></p><p>最后推荐一个博主   @生活大爆炸TBBT  (良心字幕组）<br>                    一个Up主:怪盗魔王MagicOne(英语学习博主）</p>]]></content>
      
      
      <categories>
          
          <category> Life&amp;SomethingElse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -美剧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV操作题目</title>
      <link href="/2019/05/17/PV/"/>
      <url>/2019/05/17/PV/</url>
      
        <content type="html"><![CDATA[<p>面试题：写一个固定容量的同步容器</p><p>据说是淘宝？很久以前的一道面试题：</p><pre><code>面试题：写一个固定容量的同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用</code></pre><a id="more"></a><p>wait/notifyAll实现：</p><p>public class MyContainer1<t> {<br>    final private LinkedList<t> lists = new LinkedList&lt;&gt;();<br>    final private int MAX = 10; //固定容量,假定最多10个元素<br>    private int count = 0;</t></t></p><pre><code>//put方法public synchronized void put(T t) {    while(lists.size() == MAX) { //想想为什么用while而不是用if？        try {            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    lists.add(t);    ++count;    this.notifyAll(); //通知消费者线程进行消费}    //get方法public synchronized T get() {    T t = null;    while(lists.size() == 0) {        try {            this.wait();        } catch (InterruptedException e) {            e.printStackTrace();        }    }    t = lists.removeFirst();    count --;    this.notifyAll(); //通知生产者进行生产    return t;}public static void main(String[] args) {    MyContainer1&lt;String&gt; c = new MyContainer1&lt;&gt;();    //启动消费者线程    for(int i=0; i&lt;10; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;5; j++)                               System.out.println(c.get());        }, &quot;c&quot; + i).start();    }    try {        TimeUnit.SECONDS.sleep(2);    } catch (InterruptedException e) {        e.printStackTrace();    }    //启动生产者线程    for(int i=0; i&lt;2; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;25; j++)                               c.put(Thread.currentThread().getName() + &quot; &quot; + j);        }, &quot;p&quot; + i).start();    }}</code></pre><p>对于初学者，这个面试题的难点在于：</p><p>首先，能想到在MyContainer中塞入LinkedList作为容器（因为有removeFirst方法，比较方便）。Java集合体系中，已经提供了足够多的容器，我们如果要模拟自己的容器，一般会选择将现有的容器包装进自己的容器中，而不是去自己实现一个容器。</p><p>其次，wait方法必须配合notifyAll。据说《Effective Java》甚至提出，wait在绝大多数场景下应该伴随着notifyAll而不是notify。因为notify的唤醒是随机，不能确定唤醒的是哪个线程（可能是消费者方，也可能是生产者方）。所以当某个生产者线程生产完第10个商品让出执行权后，下次抢到执行权的可能还是生产者方的其他线程（触发lists.size()==MAX条件），这样全部生产者线程就会等待（在此之前消费者线程也已经全部等待），整个程序就会发生死锁：<br>第⑤步只是举个例子，实际上也有可能是唤醒消费者，因为notify的唤醒是随机的</p><p>如果还是有同学不明白为什么生产者线程最终会全部等待，可以看看下面的例子，虽然不够贴切，但是以我的美术功底，尽力了：</p><p>如果是notifyAll，则会唤醒所有线程，且各个线程抢到执行权的概率是一致的。即使下一次还是生产者线程抢到执行权并且等待了，此时还有其他线程是活着的。</p><p>最后，由于理论上锁可以是任意对象，所以锁的wait/notify/notifyAll等方法就被定义在Object类中，让所有类去继承。如果你仍觉得synchronized才是锁，这个问题是解释不通的。所以，请明确，wait/notify/notifyAll这些方法都是锁对象的方法，线程之所以会产生等待、唤醒等一系列状态，都是去读取锁对象时被指定的。<br>wait<br>notify<br>notifyAll</p><p>最后，提供ReentrantLock实现的版本，更为简单，而且可以精确唤醒生产者线程/消费者线程：</p><p>public class MyContainer2<t> {<br>    final private LinkedList<t> lists = new LinkedList&lt;&gt;();<br>    final private int MAX = 10; //最多10个元素<br>    private int count = 0;</t></t></p><pre><code>private Lock lock = new ReentrantLock();private Condition producer = lock.newCondition();private Condition consumer = lock.newCondition();public void put(T t) {    try {        lock.lock();        while(lists.size() == MAX) { //想想为什么用while而不是用if？            producer.await();        }        lists.add(t);        ++count;        consumer.signalAll(); //通知消费者线程进行消费    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        lock.unlock();    }}public T get() {    T t = null;    try {        lock.lock();        while(lists.size() == 0) {            consumer.await();        }        t = lists.removeFirst();        count --;        producer.signalAll(); //通知生产者进行生产    } catch (InterruptedException e) {        e.printStackTrace();    } finally {        lock.unlock();    }    return t;}public static void main(String[] args) {    MyContainer2&lt;String&gt; c = new MyContainer2&lt;&gt;();    //启动消费者线程    for(int i=0; i&lt;10; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;5; j++) System.out.println(c.get());        }, &quot;c&quot; + i).start();    }    try {        TimeUnit.SECONDS.sleep(2);    } catch (InterruptedException e) {        e.printStackTrace();    }    //启动生产者线程    for(int i=0; i&lt;2; i++) {        new Thread(()-&gt;{            for(int j=0; j&lt;25; j++) c.put(Thread.currentThread().getName() + &quot; &quot; + j);        }, &quot;p&quot; + i).start();    }}</code></pre><p><strong><em>注明：转自知乎大佬 <a href="https://zhuanlan.zhihu.com/p/57482990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57482990</a>   的专栏</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程（一）</title>
      <link href="/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>&ensp;线程与进程：<br>&ensp;&ensp;一个进程至少有一个线程。线程是进程的执行单元，是进程内的可调度实体。</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>&ensp;Java实现多线程的比较简单两种方式：<br>&ensp;&ensp;1.继承Thread类。<br>&ensp;&ensp;2.实现Runnable接口。<br>&ensp;Java单根继承，不支持多继承。可以实现多个接口。<br>&ensp;一般推荐实现Runnable接口的方式。主要原因可以归结为:<br>    资源和线程分离，更加面向对象;可以做到资源共享</p><hr><p>&ensp;&ensp; <strong>继承Thread类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> public class ThreadTest extends Thread&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    System.out.println(&quot;ThreadTest&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">      ThreadTest test=new ThreadTest();</span><br><span class="line">      test.start();</span><br><span class="line">      System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516153705868.png" alt="运行结果图"></p><p>&ensp;&ensp;线程调用的随机性：线程是一个子任务，cpu以一个不确定方式或者以一个随机时间调用线程中的run方法。CPU执行哪个线程具有不确定性。Thread.java类中的start（方法通知“线程规划器”次线程已经准备就绪。等待调用线程对象的run()。这个过程就是让系统安排一个时间来调用Thread中的run()方法。也就是使得线程得到运行。启动线程具有异步效果。如果调用的不是start()而是run()就不是异步执行，而是同步。（线程启动顺序与start()执行顺序无关）此线程不交给线程规划器，而是由主线程调用run()，就是等run()代码执行完，才能执行后面代码。</p><hr><p>&ensp;&ensp; <strong>实现Runnable接口：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ThreadRun implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;Runnable&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">      ThreadRun threadTest=new ThreadRun();</span><br><span class="line">      Thread thread=new Thread(threadTest);</span><br><span class="line">      thread.start();</span><br><span class="line">      System.out.println(&quot;end&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;&ensp;运行结果与继承方式一样。<br>&ensp;&ensp;Thread.java类有8个构造函数，其中两个构造函数Thread(Runnable target)和Thread(Runnable target,String name）可以传递Runnable接口，说明参数可以是Runnable接口的对象。Thread.java类也实现了Runnable接口，意味着构造函数不仅可以传入Runnable接口的对象，还可以传入Thread类对象。这样完全可以将一个Thread对象中的run()方法交由其他线程调用。</p><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>&ensp;<strong>实例变量与线程安全：</strong><br>&ensp;&ensp;自定义线程间的实例变量：<br>&ensp;&ensp;1.共享数据<br>&ensp;&ensp;2.不共享数据<br>&ensp;<strong>不共享数据例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTheard extends Thread&#123;</span><br><span class="line">private int count=5;</span><br><span class="line">public MyTheard(String name)&#123;</span><br><span class="line">super();</span><br><span class="line">this.setName(name);</span><br><span class="line">&#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    while(count&gt;0)&#123;</span><br><span class="line">    count--;   System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot;计算,count&quot;+count);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MyTheard a=new MyTheard(&quot;A&quot;);</span><br><span class="line">MyTheard b=new MyTheard(&quot;B&quot;);</span><br><span class="line">MyTheard c=new MyTheard(&quot;C&quot;);</span><br><span class="line">a.start();</span><br><span class="line">b.start();</span><br><span class="line">c.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516165957449.png" alt="运行结果"><br>&ensp;&ensp; 此过程创建了三个线程。每个线程有自己的count变量。每个线程在自己的count变量上做操作。这种情况下线程不共享数据。不存在多个线程共享一个实例变量的情况。<br>&ensp;<strong>共享数据的例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class MyTheard extends Thread&#123;</span><br><span class="line">private int count=5;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">    super.run();</span><br><span class="line">    count--;System.out.println(&quot;由&quot;+this.currentThread().getName()+&quot;计算,count&quot;+count);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MyTheard thread=new MyTheard();</span><br><span class="line">Thread a=new Thread(thread,&quot;A&quot;);</span><br><span class="line">Thread b=new Thread(thread,&quot;B&quot;);</span><br><span class="line">Thread c=new Thread(thread,&quot;C&quot;);</span><br><span class="line">Thread d=new Thread(thread,&quot;D&quot;);</span><br><span class="line">Thread e=new Thread(thread,&quot;E&quot;);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        d.start();</span><br><span class="line">        e.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&ensp;运行结果：<br><img src="https://img-blog.csdnimg.cn/20190516170736378.png" alt="运行结果"><br>&ensp;&ensp;分析结果：共享数据的情况就是多个线程访问同一个变量。C,D打印结果都是1，说明CD同时对count做了操作。多个线程同时对同一个变量做操作。一定会出现线程安全问题。这时，就需要线程同步来解决安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于静态帧的行识别</title>
      <link href="/2019/05/02/DL01/"/>
      <url>/2019/05/02/DL01/</url>
      
        <content type="html"><![CDATA[<h6 id="图像表达："><a href="#图像表达：" class="headerlink" title="图像表达："></a>图像表达：</h6><p>特征分类：<br>低层特征：结构简单的监测子得到的特征，表示的是图像边缘以及角点分布信息 Sobel检测子、Canny SIFT<br>中层特征：复杂结构的结构描述 如人体的躯干 车辆的外形 这类方法是基于低层特征的进一步描述 shape context  SPM Poselet<br>高层特征:图像的属性特征，如个体姿态 周围环境 季节 整个算法得到的最后图像描述。<br>以上：人工设计提取特征<br>缺点：针对不同识别任务需要选择不同的特征表达图像 单一特征表达难包含识别所需要的信息  所以很多都采用特征融合<br><a id="more"></a><br>基于深度学习的图像表达技术：<br>深度学习：从大量样本中学到样本包含的统计特性<br>只是将整张图片看做图像分类 效果不好：原因同一个动作的在不同个体上有细微差别 行为中人的姿态与外观是多变的<br>试验了VGG16:发现只是在已有的数据集上效果较好，考虑到数据集 测试集的特征分布不同域问题<br>所以，解决方案可能有：<br>1.重要区域提取，比如说交互区域获取 主要区域获取等      基于目标检测算法<br>2.可能作用不是很大 有待研究   </p>]]></content>
      
      
      <categories>
          
          <category> DL学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer3</title>
      <link href="/2019/05/01/%E5%89%91%E6%8C%87Offer3/"/>
      <url>/2019/05/01/%E5%89%91%E6%8C%87Offer3/</url>
      
        <content type="html"><![CDATA[<h5 id="题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"><a href="#题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。" class="headerlink" title="题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。"></a>题目描述：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</h5><h6 id="思路：原链表1→2→3→4-要求返回：ArrayList-4-3-2-1"><a href="#思路：原链表1→2→3→4-要求返回：ArrayList-4-3-2-1" class="headerlink" title="思路：原链表1→2→3→4  要求返回：ArrayList:{4,3,2,1}"></a>思路：原链表1→2→3→4  要求返回：ArrayList:{4,3,2,1}</h6><p>  1.使用链表反转：链表反转之后 从头遍历存入ArrayList</p><p>  2.使用两个ArrayList:链表从头遍历存入ArrayList，ArrayList反序存入另一个ArrayList</p><p>  3.利用栈的先进后出原则：链表元素入栈，栈元素出栈存入ArrayList</p><h6 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        ListNode pre=null;</span><br><span class="line">        ArrayList arr=new ArrayList&lt;&gt;();</span><br><span class="line">        while(listNode!=null)&#123;</span><br><span class="line">          ListNode cur=listNode.next;</span><br><span class="line">          listNode.next=pre;</span><br><span class="line">          pre=listNode;</span><br><span class="line">          listNode=cur;</span><br><span class="line">        &#125;</span><br><span class="line">        while(pre!=null)&#123;</span><br><span class="line">            arr.add(pre.val);</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="2-两个ArrayList："><a href="#2-两个ArrayList：" class="headerlink" title="2.两个ArrayList："></a>2.两个ArrayList：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">         ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">            while (listNode != null) &#123;</span><br><span class="line">                arrayList.add(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">          for(int i=arrayList.size()-1;i&gt;=0;i--)&#123;</span><br><span class="line">              result.add(arrayList.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-栈方式"><a href="#3-栈方式" class="headerlink" title="3.栈方式"></a>3.栈方式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next = null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val = val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Stack;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">     </span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">            Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">            while (listNode != null) &#123;</span><br><span class="line">                stack.push(listNode.val);</span><br><span class="line">                listNode = listNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            while (!stack.isEmpty()) &#123;</span><br><span class="line">                arrayList.add(stack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            return arrayList;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer1-2</title>
      <link href="/2019/05/01/%E5%89%91%E6%8C%87Offer/"/>
      <url>/2019/05/01/%E5%89%91%E6%8C%87Offer/</url>
      
        <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>题解：二维数组是从左到右递增，从上到下增。所以用查找目标target与右上角或者左下角元素比较。以右上角为例，如果target大于右上角元素行向下移动，小于列左移。直到超出边界都没找到，返回FALSE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">int col=arra[0].length-1;</span><br><span class="line">int row=0;</span><br><span class="line">while(row&lt;=array.length-1&amp;&amp;col&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">if(target==array[row][col])</span><br><span class="line">return true;</span><br><span class="line">else if(target&gt;array[row][col])</span><br><span class="line">row++;</span><br><span class="line">else</span><br><span class="line">col--;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>题解：需要判断每个字符还不是为空格，不是存到结果是的话，替换为%20存入。</p><pre><code>所以：用StringBuffer格式保存新生成字符串。  可以使用charAt(index)判断每一字符，等于空格，StringBuffer.append(&quot;%20&quot;),否则直接把这个index下的char存入结果。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        StringBuffer newStr=new StringBuffer();</span><br><span class="line">        for(int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            if(str.charAt(i)==&apos; &apos;)&#123;</span><br><span class="line">                newStr.append(&quot;%20&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">              newStr.append(str.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        return newStr.toString();</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
